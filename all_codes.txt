index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deego</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

// =========================================

package.json

{
  "name": "nebula-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@codemirror/lang-sql": "^6.10.0",
    "@uiw/react-codemirror": "^4.25.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.6.0",
    "sql-formatter": "^15.6.9",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.1.0",
    "vite": "^5.1.0"
  }
}

// =========================================

src/actions/dbActions.js

import toast from 'react-hot-toast';
import { useTreeStore } from '../stores/useTreeStore';
import { useTreeConfigStore } from '../stores/useTreeConfigStore';  // Êñ∞Â¢û
import { findConnectionId, loadNodeChildren } from '../utils/treeUtils';  // Êñ∞Â¢ûÂØºÂÖ•

const treeConfigStore = window.treeConfigStore || { getState: () => ({ getConfig: () => ({}), getNextLevelConfig: () => ({}) }) };

// Êò†Â∞Ñ handler Âà∞ÂáΩÊï∞ÔºàÁé∞Êúâ + Êñ∞Â¢ûÊ®°ÊãüÔºâ
const actionHandlers = {
  // Áé∞Êúâ
  refreshDatabase: (node, setExpandedKeys) => {
    if (!node.connected) return;
    loadNodeChildren(node).then((updated) => {
      useTreeStore.getState().updateTreePath(node.id, () => updated);
      toast.success(`Âà∑Êñ∞Êï∞ÊçÆÂ∫ì: ${node.name}`);
      setExpandedKeys((prev) => new Map(prev).set(node.id, true));
    });
  },
  createNewSchema: (node) => toast(`Êñ∞Âª∫SchemaÂú®Êï∞ÊçÆÂ∫ì: ${node.name}`),
  exportDatabase: (node) => toast(`ÂØºÂá∫Êï∞ÊçÆÂ∫ì: ${node.name}`),
  refreshSchema: (node, setExpandedKeys) => {
    if (!node.connected) return;
    loadNodeChildren(node).then((updated) => {
      useTreeStore.getState().updateTreePath(node.id, () => updated);
      toast.success(`Âà∑Êñ∞ Schema: ${node.name}`);
      setExpandedKeys((prev) => new Map(prev).set(node.id, true));
    });
  },
  createNewTable: (node) => toast(`Êñ∞Âª∫Ë°®Âú®Êû∂ÊûÑ: ${node.name}`),
  createNewView: (node) => toast(`Êñ∞Âª∫ËßÜÂõæÂú®Êû∂ÊûÑ: ${node.name}`),
  createNewFunction: (node) => toast(`Êñ∞Âª∫ÂáΩÊï∞Âú®Êû∂ÊûÑ: ${node.name}`),
  exportSchema: (node) => toast(`ÂØºÂá∫Êû∂ÊûÑ: ${node.name}`),
  previewTable: (node) => toast(`È¢ÑËßàË°®: ${node.name}`),
  editTableStructure: (node) => toast(`ÁºñËæëË°®ÁªìÊûÑ: ${node.name}`),
  generateTableSQL: (node) => toast(`ÁîüÊàêSQL: ${node.name}`),
  exportTableData: (node) => toast(`ÂØºÂá∫Êï∞ÊçÆ: ${node.name}`),
  viewDefinition: (node) => toast(`Êü•ÁúãÂÆö‰πâ: ${node.name}`),
  editView: (node) => toast(`ÁºñËæëËßÜÂõæ: ${node.name}`),
  generateViewSQL: (node) => toast(`ÁîüÊàêËßÜÂõæSQL: ${node.name}`),
  editFunction: (node) => toast(`ÁºñËæëÂáΩÊï∞: ${node.name}`),
  viewFunctionSource: (node) => toast(`Êü•ÁúãÊ∫êÁ†Å: ${node.name}`),
  testFunction: (node) => toast(`ÊµãËØïÂáΩÊï∞: ${node.name}`),
  showProperties: (node) => toast(`ËäÇÁÇπÂ±ûÊÄß:\nID: ${node.id}\nÁ±ªÂûã: ${node.type}\nÂêçÁß∞: ${node.name}\nËøûÊé•Áä∂ÊÄÅ: ${node.connected ? 'Â∑≤ËøûÊé•' : 'Êú™ËøûÊé•'}`),
  deleteDatabase: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§Êï∞ÊçÆÂ∫ì`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§Êï∞ÊçÆÂ∫ì "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const response = await fetch('/api/db/delete-database', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, dbName: node.name })
          });
          if (!response.ok) throw new Error('Failed to delete database');
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`Êï∞ÊçÆÂ∫ì "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  deleteSchema: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§Schema`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§Schema "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const dbName = node.dbName || 'default';
          const response = await fetch('/api/db/delete-schema', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, dbName, schemaName: node.name })
          });
          if (!response.ok) throw new Error('Failed to delete schema');
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`Schema "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  deleteTable: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§Ë°®`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§Ë°® "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const dbName = node.dbName || 'default';
          const schemaName = node.schemaName || 'public';
          const response = await fetch('/api/db/delete-object', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, dbName, schemaName, objectName: node.name, objectType: 'table' })
          });
          if (!response.ok) throw new Error(`Failed to delete table`);
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`Ë°® "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  deleteView: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§ËßÜÂõæ`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§ËßÜÂõæ "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const dbName = node.dbName || 'default';
          const schemaName = node.schemaName || 'public';
          const response = await fetch('/api/db/delete-object', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, dbName, schemaName, objectName: node.name, objectType: 'view' })
          });
          if (!response.ok) throw new Error(`Failed to delete view`);
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`ËßÜÂõæ "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  deleteFunction: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§ÂáΩÊï∞`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§ÂáΩÊï∞ "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const dbName = node.dbName || 'default';
          const schemaName = node.schemaName || 'public';
          const response = await fetch('/api/db/delete-object', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, dbName, schemaName, objectName: node.name, objectType: 'function' })
          });
          if (!response.ok) throw new Error(`Failed to delete function`);
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`ÂáΩÊï∞ "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  // Êñ∞Â¢û PostgreSQL ÁâπÂÆö
  refreshMaterializedView: (node) => toast(`Âà∑Êñ∞Áâ©ÂåñËßÜÂõæ: ${node.name}`),
  viewPublication: (node) => toast(`Êü•Áúã Publication: ${node.name}`),
  createPublication: (node) => toast(`Êñ∞Âª∫ Publication Âú®ËøûÊé•: ${node.name}`),
  deletePublication: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§ Publication`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§ Publication "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const response = await fetch('/api/db/delete-publication', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, pubName: node.name })
          });
          if (!response.ok) throw new Error('Failed to delete publication');
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`Publication "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  showRoleProperties: (node) => toast(`ËßíËâ≤Â±ûÊÄß: ${node.name}`),
  createRole: (node) => toast(`Êñ∞Âª∫ËßíËâ≤: ${node.name}`),
  deleteRole: async (node, openModal) => {
    if (typeof openModal !== 'function') {
      toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
      return;
    }
    const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
      openModal('confirm', {
        title,
        message,
        onConfirm,
        variant
      });
    };

    localOpenConfirm(
      `Âà†Èô§ËßíËâ≤`,
      `Á°ÆÂÆöË¶ÅÂà†Èô§ËßíËâ≤ "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      async () => {
        try {
          const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
          const response = await fetch('/api/db/delete-role', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ connectionId, roleName: node.name })
          });
          if (!response.ok) throw new Error('Failed to delete role');
          useTreeStore.getState().deleteNode(node.id);
          toast.success(`ËßíËâ≤ "${node.name}" Â∑≤Âà†Èô§`);
        } catch (error) {
          toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      },
      'danger'
    );
  },
  // ÈÄöÁî®Âä®ÊÄÅË∞ÉÁî®
  dynamicHandler: async (handler, node, options = {}) => {
    const { setExpandedKeys, openModal } = options;
    if (actionHandlers[handler]) {
      return actionHandlers[handler](node, openModal, setExpandedKeys);
    } else {
      // ÂêéÁ´Ø API fallback
      try {
        const response = await fetch(`/api/db/${handler}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ nodeId: node.id }),
        });
        if (!response.ok) throw new Error('Action failed');
        toast.success(`${handler} ÊâßË°åÊàêÂäü`);
      } catch (error) {
        toast.error(`${handler} ÊâßË°åÂ§±Ë¥•: ${error.message}`);
      }
    }
  }
};

// getPrimaryActionÔºö‰ªé config.actions.primary Ëé∑Âèñ
export const getPrimaryAction = (node) => {
  const primary = node.config?.actions?.primary;
  if (primary) {
    return { icon: primary.icon, label: primary.label, handler: primary.handler };
  }
  // Fallback ÊóßÈÄªËæë
  const actions = {
    folder: { icon: 'üîå', label: 'Êñ∞Âª∫ËøûÊé•' },
    connection: { icon: '‚ö°', label: 'ËøûÊé•' },
    database: { icon: 'üîÑ', label: 'Âà∑Êñ∞' },
    schema: { icon: 'üîÑ', label: 'Âà∑Êñ∞' },
    table: { icon: 'üìä', label: 'È¢ÑËßà' },
    view: { icon: 'üëÅÔ∏è', label: 'Êü•Áúã' },
    function: { icon: '‚öôÔ∏è', label: 'ÁºñËæë' },
    // Êñ∞Â¢û group Á±ªÂûã
    table_group: { icon: 'üìä', label: 'Â±ïÂºÄ Tables' },
    view_group: { icon: 'üëÅÔ∏è', label: 'Â±ïÂºÄ Views' },
    function_group: { icon: '‚öôÔ∏è', label: 'Â±ïÂºÄ Functions' },
    mview_group: { icon: 'üìä', label: 'Â±ïÂºÄ Materialized Views' },
    publications: { icon: 'üëÅÔ∏è', label: 'Êü•Áúã' },
    roles: { icon: '‚ÑπÔ∏è', label: 'Â±ûÊÄß' }
  };
  return actions[node.type] || null;
};

// getAllActionsÔºöÂä®ÊÄÅ‰ªé config.actions.menu ÁîüÊàêÔºåÊîØÊåÅ fallback
export const getAllActions = (
  nodeType,
  node,
  setExpandedKeys,
  openNewGroup,
  openNewConnection,
  openConfirm,
  openRenameFolder,
  openEditConnection,
  refreshFolder,
  deleteFolder,
  refreshConnection,
  connectDatabase,
  disconnectDatabase,
  refreshDatabase,
  refreshSchema,
  createNewSchema,
  exportDatabase,
  createNewTable,
  exportSchema,
  previewTable,
  editTableStructure,
  generateTableSQL,
  exportTableData,
  viewDefinition,
  editView,
  generateViewSQL,
  editFunction,
  viewFunctionSource,
  testFunction,
  showProperties,
  deleteConnection,
  deleteDatabase,
  deleteSchema,
  deleteTable,
  deleteView,
  deleteFunction
) => {
  const configActions = node.config?.actions?.menu || [];
  const mappedActions = configActions.map((act) => ({
    label: act.label,
    icon: act.icon,
    type: act.type || null,  // separator
    variant: act.variant || null,
    action: () => actionHandlers.dynamicHandler(act.handler, node, { setExpandedKeys, openModal: openConfirm })
  }));

  // Fallback Êóß actions[nodeType]ÔºåÈÅøÂÖçÈáçÂ§ç
  const oldActionsMap = {
    folder: [
      { label: 'Êñ∞Âª∫Êñá‰ª∂Â§π', action: () => openNewGroup(node.id), icon: 'üìÅ' },
      { label: 'Êñ∞Âª∫ËøûÊé•', action: () => openNewConnection(node.id), icon: 'üîå' },
      { type: 'separator' },
      { label: 'Âà∑Êñ∞', action: () => refreshFolder(node), icon: 'üîÑ' },
      { type: 'separator' },
      { label: 'Âà†Èô§Êñá‰ª∂Â§π', action: () => deleteFolder(node), icon: 'üóëÔ∏è' },
      { label: 'ÈáçÂëΩÂêç', action: () => openRenameFolder(node), icon: '‚úèÔ∏è' }
    ],
    connection: [
      { label: 'ËøûÊé•', action: () => connectDatabase(node), icon: '‚ö°' },
      { label: 'Êñ≠ÂºÄËøûÊé•', action: () => disconnectDatabase(node), icon: 'üîå' },
      { type: 'separator' },
      { label: 'Âà∑Êñ∞', action: () => refreshConnection(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'ËøûÊé•ËÆæÁΩÆ', action: () => openEditConnection(node), icon: '‚öôÔ∏è' },
      { type: 'separator' },
      { label: 'Âà†Èô§ËøûÊé•', action: () => deleteConnection(node), icon: 'üóëÔ∏è' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    database: [
      { label: 'Âà∑Êñ∞', action: () => refreshDatabase(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'Êñ∞Âª∫Schema', action: () => createNewSchema(node), icon: 'üìÅ' },
      { label: 'ÂØºÂá∫ÁªìÊûÑ', action: () => exportDatabase(node), icon: 'üì§' },
      { type: 'separator' },
      { label: 'Âà†Èô§Êï∞ÊçÆÂ∫ì', action: () => deleteDatabase(node), icon: 'üóëÔ∏è' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    schema: [
      { label: 'Âà∑Êñ∞', action: () => refreshSchema(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'Êñ∞Âª∫Ë°®', action: () => createNewTable(node), icon: 'üìä' },
      { label: 'ÂØºÂá∫ÁªìÊûÑ', action: () => exportSchema(node), icon: 'üì§' },
      { type: 'separator' },
      { label: 'Âà†Èô§Schema', action: () => deleteSchema(node), icon: 'üóëÔ∏è' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    table: [
      { label: 'È¢ÑËßàÊï∞ÊçÆ', action: () => previewTable(node), icon: 'üìä' },
      { label: 'ÁºñËæëÁªìÊûÑ', action: () => editTableStructure(node), icon: '‚úèÔ∏è' },
      { label: 'ÁîüÊàêSQL', action: () => generateTableSQL(node), icon: 'üíæ' },
      { label: 'ÂØºÂá∫Êï∞ÊçÆ', action: () => exportTableData(node), icon: 'üì§' },
      { type: 'separator' },
      { label: 'Âà†Èô§Ë°®', action: () => deleteTable(node), icon: 'üóëÔ∏è' },
      { type: 'separator' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    view: [
      { label: 'Êü•ÁúãÂÆö‰πâ', action: () => viewDefinition(node), icon: 'üëÅÔ∏è' },
      { label: 'ÁºñËæëËßÜÂõæ', action: () => editView(node), icon: '‚úèÔ∏è' },
      { label: 'ÁîüÊàêSQL', action: () => generateViewSQL(node), icon: 'üíæ' },
      { type: 'separator' },
      { label: 'Âà†Èô§ËßÜÂõæ', action: () => deleteView(node), icon: 'üóëÔ∏è' },
      { type: 'separator' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    function: [
      { label: 'ÁºñËæëÂáΩÊï∞', action: () => editFunction(node), icon: '‚úèÔ∏è' },
      { label: 'Êü•ÁúãÊ∫êÁ†Å', action: () => viewFunctionSource(node), icon: 'üëÅÔ∏è' },
      { label: 'ÊâßË°åÊµãËØï', action: () => testFunction(node), icon: 'üî¨' },
      { type: 'separator' },
      { label: 'Âà†Èô§ÂáΩÊï∞', action: () => deleteFunction(node), icon: 'üóëÔ∏è' },
      { type: 'separator' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    // Êñ∞Â¢û group fallback (ÁÆÄÂçïÔºåÁªßÊâø primary)
    table_group: [
      { label: 'Âà∑Êñ∞', action: () => refreshSchema(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    view_group: [
      { label: 'Âà∑Êñ∞', action: () => refreshSchema(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    function_group: [
      { label: 'Âà∑Êñ∞', action: () => refreshSchema(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    mview_group: [
      { label: 'Âà∑Êñ∞', action: () => refreshSchema(node, setExpandedKeys), icon: 'üîÑ' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    publications: [
      { label: 'Êñ∞Âª∫ Publication', action: () => actionHandlers.createPublication(node), icon: '‚ûï' },
      { type: 'separator' },
      { label: 'Âà†Èô§', action: () => actionHandlers.deletePublication(node, openConfirm), icon: 'üóëÔ∏è' },
      { label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }
    ],
    roles: [
      { label: 'Êñ∞Âª∫ËßíËâ≤', action: () => actionHandlers.createRole(node), icon: '‚ûï' },
      { type: 'separator' },
      { label: 'Âà†Èô§ËßíËâ≤', action: () => actionHandlers.deleteRole(node, openConfirm), icon: 'üóëÔ∏è' },
      { label: 'Â±ûÊÄß', action: () => actionHandlers.showRoleProperties(node), icon: '‚ÑπÔ∏è' }
    ]
  };
  const fallback = oldActionsMap[nodeType] || [{ label: 'Â±ûÊÄß', action: () => showProperties(node), icon: '‚ÑπÔ∏è' }];

  // ÂêàÂπ∂ÔºåÈÅøÂÖçÈáçÂ§ç label
  const seenLabels = new Set(mappedActions.map(a => a.label));
  const uniqueFallback = fallback.filter(a => !seenLabels.has(a.label));

  return [...mappedActions, ...uniqueFallback];
};

// Êõ¥Êñ∞ËøûÊé•ÔºàËá™Âä®Â±ïÁ§∫ÔºöÂä†ËΩΩ‰∏≠ ‚Üí ÊàêÂäü/Â§±Ë¥•Ôºâ
export const updateConnection = async (payload) => {
  const { updateTreePath } = useTreeStore.getState();
  return toast.promise(
      (async () => {
        const response = await fetch(`/api/config/connections/${payload.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!response.ok) throw new Error('Failed to update connection');

        // Êú¨Âú∞Áä∂ÊÄÅÊõ¥Êñ∞
        updateTreePath(payload.id, (current) => ({
          ...current,
          name: payload.name,
          dbType: payload.dbType,
          host: payload.host,
          port: payload.port,
          database: payload.database,
          username: payload.username,
        }));

        return true; // ÊàêÂäüÂàÜÊîØ
      })(),
      {
        loading: '‰øùÂ≠òËøûÊé•‰∏≠...',
        success: `ËøûÊé• "${payload.name}" Â∑≤Êõ¥Êñ∞`,
        error: 'Êõ¥Êñ∞Â§±Ë¥•ÔºåËØ∑ÈáçËØï',
      }
  );
};

// ËøûÊé•Êï∞ÊçÆÂ∫ìÔºàËøîÂõû PromiseÔºå‰æø‰∫éÂêéÁª≠Ëá™Âä®Â±ïÂºÄÔºâ
export const connectDatabase = (node) => {
  const { updateTreePath, loadTreeConfig } = useTreeStore.getState();
  if (node.connected) {
    toast(`Â∑≤ËøûÊé•: ${node.name}`);
    return Promise.resolve(false);
  }
  return (async () => {
    const r = await fetch(`/api/config/connections/${encodeURIComponent(node.id)}/test`, { method: 'GET' });
    if (!r.ok) {
      const msg = await r.text();
      toast.error(msg || 'ËøûÊé•Â§±Ë¥•');
      return false;
    }
    updateTreePath(node.id, (cur) => ({ ...cur, connected: true, status: 'connected' }));
    await loadTreeConfig(node.id);  // Êñ∞Â¢ûÔºöÂä†ËΩΩ YAML ÈÖçÁΩÆ
    toast.success(`Â∑≤ËøûÊé•: ${node.name}`);
    return true;
  })();
};


// Êñ≠ÂºÄËøûÊé•
export const disconnectDatabase = (node) => {
  const { updateTreePath } = useTreeStore.getState();
  if (!node.connected) {
    toast(`Êú™ËøûÊé•: ${node.name}`);
    return;
  }
  updateTreePath(node.id, (current) => ({
    ...current,
    connected: false,
    status: 'disconnected',
    children: [],
    config: {}  // Ê∏ÖÁ©∫ÈÖçÁΩÆ
  }));
  toast.success(`Êñ≠ÂºÄËøûÊé•: ${node.name}`);
};

// Âà∑Êñ∞ËøûÊé•
export const refreshConnection = (node, setExpandedKeys) => {
  if (!node.connected) {
    toast.error('ËØ∑ÂÖàËøûÊé•');
    return;
  }
  setTimeout(() => {
    // Ê®°ÊãüÂà∑Êñ∞ÔºåÂÆûÈôÖË∞ÉÁî® API
    toast.success(`Âà∑Êñ∞ÊàêÂäü: ${node.name}`);
    setExpandedKeys((prev) => new Map(prev).set(node.id, true));
  }, 300);
};

// Âà∑Êñ∞Êï∞ÊçÆÂ∫ì
export const refreshDatabase = (node, setExpandedKeys) => {
  actionHandlers.refreshDatabase(node, setExpandedKeys);
};

// Âà∑Êñ∞ Schema
export const refreshSchema = (node, setExpandedKeys) => {
  actionHandlers.refreshSchema(node, setExpandedKeys);
};

// Âà†Èô§ËøûÊé•
export const deleteConnection = async (node, openModal) => {
  if (typeof openModal !== 'function') {
    toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
    return;
  }
  const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
    openModal('confirm', {
      title,
      message,
      onConfirm,
      variant
    });
  };

  localOpenConfirm(
    `Âà†Èô§ËøûÊé•`,
    `Á°ÆÂÆöË¶ÅÂà†Èô§ËøûÊé• "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
    async () => {
      try {
        const response = await fetch(`/api/config/connections/${node.id}`, { method: 'DELETE' });
        if (!response.ok) throw new Error('Failed to delete connection');
        useTreeStore.getState().deleteNode(node.id);
        toast.success(`ËøûÊé• "${node.name}" Â∑≤Âà†Èô§`);
      } catch (error) {
        toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      }
    },
    'danger'
  );
};

// Âà†Èô§Êï∞ÊçÆÂ∫ì
export const deleteDatabase = async (node, openModal) => {
  actionHandlers.deleteDatabase(node, openModal);
};

// Âà†Èô§ Schema
export const deleteSchema = async (node, openModal) => {
  actionHandlers.deleteSchema(node, openModal);
};

// ÈÄöÁî®Âà†Èô§ DB ÂØπË±°
const deleteDbObject = async (node, objectType, openModal) => {
  if (typeof openModal !== 'function') {
    toast.error('Ê®°ÊÄÅÊâìÂºÄÂ§±Ë¥•');
    return;
  }
  const label = objectType === 'table' ? 'Ë°®' : objectType === 'view' ? 'ËßÜÂõæ' : 'ÂáΩÊï∞';
  const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
    openModal('confirm', {
      title,
      message,
      onConfirm,
      variant
    });
  };

  localOpenConfirm(
    `Âà†Èô§${label}`,
    `Á°ÆÂÆöË¶ÅÂà†Èô§${label} "${node.name}" ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
    async () => {
      try {
        const connectionId = findConnectionId(node.id, useTreeStore.getState().treeData);
        const dbName = node.dbName || 'default';
        const schemaName = node.schemaName || 'public';
        const response = await fetch('/api/db/delete-object', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ connectionId, dbName, schemaName, objectName: node.name, objectType })
        });
        if (!response.ok) throw new Error(`Failed to delete ${objectType}`);
        useTreeStore.getState().deleteNode(node.id);
        toast.success(`${label} "${node.name}" Â∑≤Âà†Èô§`);
      } catch (error) {
        toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      }
    },
    'danger'
  );
};

export const deleteTable = (node, openModal) => deleteDbObject(node, 'table', openModal);
export const deleteView = (node, openModal) => deleteDbObject(node, 'view', openModal);
export const deleteFunction = (node, openModal) => deleteDbObject(node, 'function', openModal);

// ÂÖ∂‰ªñÊìç‰ΩúÔºàÊ®°ÊãüÔºåÊ∑ªÂä† toastÔºâ
export const createNewSchema = (node) => actionHandlers.createNewSchema(node);
export const exportDatabase = (node) => actionHandlers.exportDatabase(node);
export const createNewTable = (node) => actionHandlers.createNewTable(node);
export const exportSchema = (node) => actionHandlers.exportSchema(node);
export const previewTable = (node) => actionHandlers.previewTable(node);
export const editTableStructure = (node) => actionHandlers.editTableStructure(node);
export const generateTableSQL = (node) => actionHandlers.generateTableSQL(node);
export const exportTableData = (node) => actionHandlers.exportTableData(node);
export const viewDefinition = (node) => actionHandlers.viewDefinition(node);
export const editView = (node) => actionHandlers.editView(node);
export const generateViewSQL = (node) => actionHandlers.generateViewSQL(node);
export const editFunction = (node) => actionHandlers.editFunction(node);
export const viewFunctionSource = (node) => actionHandlers.viewFunctionSource(node);
export const testFunction = (node) => actionHandlers.testFunction(node);
export const showProperties = (node) => actionHandlers.showProperties(node);
export const refreshFolder = (node) => toast(`Âà∑Êñ∞Êñá‰ª∂Â§π: ${node.name}`);

// =========================================

src/actions/treeActions.js

import toast from 'react-hot-toast';
import { findNode } from '../utils/treeUtils';
import { useTreeStore } from '../stores/useTreeStore';
import { useTreeConfigStore } from '../stores/useTreeConfigStore';  // Êñ∞Â¢û

// handleNewGroupSubmit Âíå handleNewConnectionSubmit ‰øùÊåÅÂéüÊ†∑
export const handleNewGroupSubmit = async (groupName, parentId) => {
  try {
    const response = await fetch('/api/config/folders', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: groupName, type: 'folder', parentId }),
    });
    if (!response.ok) throw new Error('Failed to create group');
    await response.json();
    useTreeStore.getState().refreshTree();
    toast.success('Êñ∞Âª∫ÂàÜÁªÑÊàêÂäü');
  } catch (err) {
    console.error('Error creating group:', err);
    toast.error('ÂàõÂª∫ÂàÜÁªÑÂ§±Ë¥•');
    throw err;
  }
};

export const handleNewConnectionSubmit = async (connectionData, parentId) => {
  try {
    const response = await fetch('/api/config/connections', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...connectionData, type: 'connection', parentId }),
    });
    if (!response.ok) throw new Error('Failed to create connection');
    await response.json();
    useTreeStore.getState().refreshTree();
    toast.success('Êñ∞Âª∫ËøûÊé•ÊàêÂäü');
  } catch (err) {
    console.error('Error creating connection:', err);
    toast.error('ÂàõÂª∫ËøûÊé•Â§±Ë¥•');
    throw err;
  }
};

// ‰øÆÂ§çÔºömoveNode Êé•Êî∂ openModal ÂèÇÊï∞ÔºåÁõ¥Êé•ÂÜÖÈÉ®Ë∞ÉÁî® openConfirmÔºå‰ΩøÁî® config.type
export const moveNode = async (sourceId, targetParentId, updateTreePathFn, openModal, nodeType) => {
  // nodeType ‰ªé config.type fallback
  const sourceNode = findNode(useTreeStore.getState().treeData, sourceId);
  const actualType = sourceNode?.config?.type || nodeType || 'unknown';
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }

  // ÂÜÖÈÉ®ÊûÑÂª∫ openConfirmÔºå‰ΩøÁî®‰º†ÂÖ•ÁöÑ openModal
  const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
    openModal('confirm', {
      title,
      message,
      onConfirm: async () => {
        try {
          await onConfirm();
        } catch (error) {
          toast.error('Êìç‰ΩúÂ§±Ë¥•');
          console.error('Move confirm error:', error);
        }
      },
      variant
    });
  };

  localOpenConfirm(
    `ÁßªÂä®${actualType === 'folder' ? 'Êñá‰ª∂Â§π' : 'ËøûÊé•'}`,
    `Á°ÆÂÆöË¶ÅÂ∞ÜÊ≠§${actualType === 'folder' ? 'Êñá‰ª∂Â§π' : 'ËøûÊé•'}ÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆÂêóÔºü`,
    async () => {
      try {
        const response = await fetch('/api/config/move-node', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sourceId, targetParentId: targetParentId || null, type: actualType })
        });
        if (!response.ok) throw new Error(`Failed to move ${actualType}`);

        // Êõ¥Êñ∞Ê†ëÊï∞ÊçÆÔºöÁßªÈô§Ê∫êËäÇÁÇπÔºåÊ∑ªÂä†Âà∞ÁõÆÊ†á
        const treeData = useTreeStore.getState().treeData;
        const newTree = JSON.parse(JSON.stringify(treeData));
        const removeNodeFromTree = (nodes, id) => {
          if (!Array.isArray(nodes)) return null;
          for (let i = 0; i < nodes.length; i++) {
            if (nodes[i] && nodes[i].id === id) {
              return nodes.splice(i, 1)[0];
            }
            if (nodes[i] && nodes[i].children) {
              const removed = removeNodeFromTree(nodes[i].children, id);
              if (removed !== null) {
                return removed;
              }
            }
          }
          return null;
        };
        const removedNode = removeNodeFromTree(newTree, sourceId);
        if (!removedNode) return;

        removedNode.parentId = targetParentId || null;
        if (!targetParentId) {
          newTree.push(removedNode);
        } else {
          const targetNode = findNode(newTree, targetParentId);
          if (targetNode && targetNode.children) {
            targetNode.children.push(removedNode);
          }
        }
        useTreeStore.getState().setTreeData(newTree);
        toast.success(`${actualType} Â∑≤ÁßªÂä®Âà∞Êñ∞‰ΩçÁΩÆ`);
      } catch (error) {
        console.error(`Move ${actualType} error:`, error);
        toast.error('ÁßªÂä®Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      }
    },
    'warning'
  );
};

// ÂàáÊç¢Â±ïÂºÄÔºö‰∏çÂèò
export const toggleExpand = (setExpandedKeys, nodeId, loadChildren = true) => {
  setExpandedKeys((prev) => {
    const newMap = new Map(prev);
    newMap.set(nodeId, !newMap.get(nodeId));
    return newMap;
  });
};

// Âà†Èô§ËäÇÁÇπÔºàÈÄöÁî®ÔºâÔºö‰∏çÂèò
export const deleteNode = (treeData, nodeId) => {
  const newTree = JSON.parse(JSON.stringify(treeData));
  function deleteRecursive(nodes) {
    if (!Array.isArray(nodes)) return false;
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i] && nodes[i].id === nodeId) {
        nodes.splice(i, 1);
        return true;
      }
      if (nodes[i] && nodes[i].children && deleteRecursive(nodes[i].children)) {
        return true;
      }
    }
    return false;
  }
  deleteRecursive(newTree);
  return newTree;
};

// Âà†Èô§Êñá‰ª∂Â§πÔºö‰∏çÂèò
export const deleteFolder = async (node, openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  const localOpenConfirm = (title, message, onConfirm, variant = 'danger') => {
    openModal('confirm', {
      title,
      message,
      onConfirm,
      variant
    });
  };

  localOpenConfirm(
    `Âà†Èô§Êñá‰ª∂Â§π`,
    `Á°ÆÂÆöË¶ÅÂà†Èô§Êñá‰ª∂Â§π "${node.name}" ÂèäÂÖ∂ÊâÄÊúâÂ≠êÈ°πÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
    async () => {
      try {
        const response = await fetch(`/api/config/folders/${node.id}`, { method: 'DELETE' });
        if (!response.ok) throw new Error('Failed to delete folder');
        useTreeStore.getState().deleteNode(node.id);
        toast.success(`Êñá‰ª∂Â§π "${node.name}" Â∑≤Âà†Èô§`);
      } catch (error) {
        toast.error('Âà†Èô§Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      }
    },
    'danger'
  );
};

// ÈáçÂëΩÂêçÊñá‰ª∂Â§πÔºö‰∏çÂèò
export const renameFolder = (node, openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  openModal('renameFolder', {
    id: node.id,
    name: node.name,
    onSubmit: async (newName) => {
      if (!newName || newName.trim() === '') {
        throw new Error('Êñá‰ª∂Â§πÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫');
      }
      try {
        const response = await fetch(`/api/config/folders`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newName.trim(), id: node.id, type: 'folder' })
        });
        if (!response.ok) throw new Error('Failed to rename folder');
        useTreeStore.getState().updateTreePath(node.id, (current) => ({
          ...current,
          name: newName.trim()
        }));
        toast.success(`Êñá‰ª∂Â§πÂ∑≤ÈáçÂëΩÂêç‰∏∫ "${newName}"`);
      } catch (error) {
        console.error('Rename folder error:', error);
        throw error;
      }
    }
  });
};

// Âà∑Êñ∞Êñá‰ª∂Â§πÔºö‰∏çÂèò
export const refreshFolder = (node) => {
  toast(`Âà∑Êñ∞Êñá‰ª∂Â§π: ${node.name}`);
  // ÂÆûÈôÖË∞ÉÁî® API Âà∑Êñ∞Â≠êÈ°π
};

// =========================================

src/App.jsx

import React, { useEffect } from 'react';
import AppLayout from './components/layout/AppLayout';
import { ModalProvider } from './components/modals/ModalProvider';
import { Toaster } from 'react-hot-toast'; // ÈÄöÁü•ÁªÑ‰ª∂
import { useTreeConfigStore } from './stores/useTreeConfigStore';  // Êñ∞Â¢ûÔºöÂàùÂßãÂåñÂÖ®Â±Ä store
import './css/index.css';

export default function App() {
  // ÁßªÈô§ Zustand ProviderÔºöZustand hooks Áõ¥Êé•Âú®ÁªÑ‰ª∂‰∏≠‰ΩøÁî®ÔºåÊó†ÈúÄÂÖ®Â±ÄÂåÖË£Ö
  useEffect(() => {
    // ÂàùÂßãÂåñÂÖ®Â±Ä treeConfigStoreÔºà‰æõ utils/dbActions fallback ‰ΩøÁî®Ôºâ
    window.treeConfigStore = useTreeConfigStore;
  }, []);

  return (
    <ModalProvider>
      <AppLayout />
      <Toaster position="top-right" />
    </ModalProvider>
  );
}

// =========================================

src/components/editor/EditorPanel.jsx

import React from 'react';
import SqlEditor from './SqlEditor';
import { useTabsStore } from '../../stores/useTabsStore';

const EditorPanel = ({ query, results, updateQuery, executeQuery, editorHeight, handleEditorMouseDown }) => {
  const { activeTabId } = useTabsStore();

  return (
    <div className="editor-and-result" style={{ height: `calc(100vh - 132px)` }}> {/* Ë∞ÉÊï¥È´òÂ∫¶‰ª•ÈÄÇÂ∫îÂ∑•ÂÖ∑Ê†è */}
      <div className="editor-area" style={{ height: editorHeight }}>
        <SqlEditor query={query} setQuery={updateQuery} />
      </div>
      <div className="resizer editor-divider" onMouseDown={handleEditorMouseDown} />
      <div className="result-area">
        <div className="result-header">
          <div className="left-controls">
            <button className="icon-btn refresh-btn" onClick={executeQuery}>‚ü≥</button>
            <span className="limit-text">Limit 1000</span>
          </div>
          <div className="right-controls">
            {results.length > 0 && <span className="row-count">{results.length} rows</span>}
          </div>
        </div>
        <div className="result-content">
          {results.length > 0 ? (
            <div className="result-table">
              <table>
                <thead>
                  <tr>
                    {results[0] && Object.keys(results[0]).map((key) => <th key={key}>{key}</th>)}
                  </tr>
                </thead>
                <tbody>
                  {results.map((row, idx) => (
                    <tr key={idx}>
                      {Object.values(row).map((value, i) => <td key={i}>{value}</td>)}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <div className="empty-state">
              <div className="empty-icon">üìä</div>
              <p>Execute a query above to see results</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default EditorPanel;

// =========================================

src/components/editor/SqlEditor.jsx

import React from 'react';
import CodeMirror from '@uiw/react-codemirror';
import { sql } from '@codemirror/lang-sql';
import '../../css/SqlEditor.css';

export default function SqlEditor({ query, setQuery }) {
  return (
    <div className="sql-editor">
      <CodeMirror
        value={query}
        onChange={setQuery}
        extensions={[sql()]}
        height="100%"
        theme="light"
        placeholder="Write your SQL here..."
        basicSetup={{
          lineNumbers: true,
          highlightActiveLine: true,
          tabSize: 2,
          bracketMatching: true,
        }}
        className="codemirror-custom"
        style={{ fontSize: '14px', fontFamily: "'Fira Code', 'SF Mono', Monaco, Consolas, monospace", fontWeight: 590 }}
      />
    </div>
  );
}

// =========================================

src/components/layout/AppLayout.jsx

import React, { useRef, useEffect, useState } from 'react';
import Sidebar from '../sidebar/Sidebar';
import ToolbarTop from '../toptoolbar/ToolbarTop';
import EditorPanel from '../editor/EditorPanel';
import { useResize } from '../../hooks/useResize';
import { useTreeStore } from '../../stores/useTreeStore';
import { useTabsStore } from '../../stores/useTabsStore';
import FormatIcon from '../../public/icons/toptoolbar/format_1.svg';
import RunIcon from '../../public/icons/toptoolbar/run_1.svg';
import StopIcon from '../../public/icons/toptoolbar/stop_1.svg';
import { openNewGroup, openNewConnection } from '../modals/modalActions'; // ‰ªéÊ®°ÊÄÅ actions ÂØºÂÖ•

const AppLayout = () => {
  const sidebarRef = useRef(null); // Á°Æ‰øù ref Â≠òÂú®
  const { sidebarWidth, editorHeight, handleSidebarMouseDown, handleEditorMouseDown } = useResize(undefined, undefined, sidebarRef); // ‰º†ÂÖ• sidebarRef
  const { treeData, refreshTree } = useTreeStore();
  const { tabs, activeTabId, updateQuery, executeQuery, formatQuery, addTab, closeTab, checkTabOverflow, handleTabScroll } = useTabsStore();
  const tabsContainerRef = useRef(null);
  const [showTabScroll, setShowTabScroll] = React.useState(false);
  const activeTab = tabs.find((t) => t.id === activeTabId) || { query: '', results: [] };

  useEffect(() => {
    refreshTree(); // ÂàùÂßãÂåñÊ†ëÊï∞ÊçÆ
  }, [refreshTree]);

  useEffect(() => {
    const timeoutId = setTimeout(() => setShowTabScroll(checkTabOverflow(tabsContainerRef)), 100);
    return () => clearTimeout(timeoutId);
  }, [tabs, checkTabOverflow]);

  useEffect(() => {
    const handleResize = () => setShowTabScroll(checkTabOverflow(tabsContainerRef));
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [checkTabOverflow]);

  const handleFormat = () => formatQuery();
  const handleRun = () => executeQuery(activeTab.query).then((results) => {
    useTabsStore.setState((state) => ({
      tabs: state.tabs.map((t) => (t.id === activeTabId ? { ...t, results } : t)),
    }));
  });

  return (
    <div className="app-container" style={{ gridTemplateColumns: `${sidebarWidth}px 1fr` }}>
      <ToolbarTop addTab={addTab} refreshTree={refreshTree} openNewGroup={() => openNewGroup(null)} openNewConnection={() => openNewConnection(null)} />
      <div ref={sidebarRef} className="sidebar" style={{ width: sidebarWidth }}>
        <Sidebar treeData={treeData} />
        <div className="resizer sidebar-resizer" onMouseDown={(e) => handleSidebarMouseDown(e)} />
      </div>
      <div className="main-panel">
        <div className="toolbar">
          <div className="toolbar-left">
            <button className="btn btn-icon" title="ÁæéÂåñsql" onClick={handleFormat}>
              <img src={FormatIcon} alt="ÁæéÂåñsql" className="icon" />
            </button>
            <button className="btn btn-icon" title="ËøêË°å" onClick={handleRun}>
              <img src={RunIcon} alt="ËøêË°å" className="icon" />
            </button>
            <button className="btn btn-icon" title="ÂÅúÊ≠¢" onClick={handleRun}>
              <img src={StopIcon} alt="ÂÅúÊ≠¢" className="icon" />
            </button>
          </div>
        </div>
        {tabs.length > 0 && (
          <div className="tabs-container">
            {showTabScroll && (
              <button className="tab-scroll-btn tab-scroll-left" onClick={() => handleTabScroll('left', tabsContainerRef)}>
                ‚Äπ
              </button>
            )}
            <div className="tabs-header" ref={tabsContainerRef}>
              {tabs.map((tab) => (
                <div
                  key={tab.id}
                  className={`tab-item ${tab.id === activeTabId ? 'active' : ''}`}
                  onClick={() => useTabsStore.getState().setActiveTabId(tab.id)}
                >
                  <span className="tab-title" title={tab.title}>{tab.title}</span>
                  {tabs.length > 1 && (
                    <button className="tab-close" onClick={(e) => { e.stopPropagation(); closeTab(tab.id); }}>
                      √ó
                    </button>
                  )}
                </div>
              ))}
            </div>
            {showTabScroll && (
              <button className="tab-scroll-btn tab-scroll-right" onClick={() => handleTabScroll('right', tabsContainerRef)}>
                ‚Ä∫
              </button>
            )}
            {tabs.length > 1 && (
              <div className="tab-counter">
                Tab {tabs.findIndex((t) => t.id === activeTabId) + 1} of {tabs.length}
              </div>
            )}
          </div>
        )}
        <EditorPanel
          query={activeTab.query}
          results={activeTab.results}
          updateQuery={updateQuery}
          executeQuery={handleRun}
          editorHeight={editorHeight}
          handleEditorMouseDown={handleEditorMouseDown}
        />
      </div>
    </div>
  );
};

export default AppLayout;

// =========================================

src/components/modals/ConfirmModal.jsx

import React from 'react';
import { createPortal } from 'react-dom';

const ConfirmModal = ({ isOpen, onClose, onConfirm, title = 'Á°ÆËÆ§Êìç‰Ωú', message = 'ÊÇ®Á°ÆÂÆöË¶ÅÊâßË°åÊ≠§Êìç‰ΩúÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ', confirmText = 'Á°ÆËÆ§', cancelText = 'ÂèñÊ∂à', variant = 'danger' }) => {
  if (!isOpen) return null;

  const handleConfirm = () => {
    onConfirm();
    onClose();
  };

  const handleCancel = onClose;

  const handleBackdropClick = (e) => {
    if (e.target === e.currentTarget) onClose();
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Escape') onClose();
    else if (e.key === 'Enter') handleConfirm();
  };

  const buttonVariant = variant === 'danger'
    ? { bg: 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)', color: 'white' }
    : { bg: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white' };

  return createPortal(
    <div
      className="confirm-modal-overlay"
      style={{
        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
        background: 'rgba(0, 0, 0, 0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center',
        zIndex: 1000, backdropFilter: 'blur(4px)'
      }}
      onClick={handleBackdropClick}
      onKeyDown={handleKeyDown}
      tabIndex={-1}
    >
      <div
        className="confirm-modal"
        style={{
          background: 'white', borderRadius: '12px', boxShadow: '0 20px 60px rgba(0, 0, 0, 0.15)',
          width: 'min(90vw, 400px)', maxWidth: '400px', padding: '24px', fontFamily: 'var(--font)',
          animation: 'modalSlideIn 0.3s ease-out'
        }}
      >
        <h2 style={{ margin: '0 0 16px 0', fontSize: '18px', fontWeight: '600', color: '#333', lineHeight: '1.4' }}>
          {title}
        </h2>
        <p style={{ margin: '0 0 24px 0', fontSize: '14px', color: '#666', lineHeight: '1.5', whiteSpace: 'pre-wrap' }}>
          {message}
        </p>
        <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '12px', marginTop: '8px' }}>
          <button
            onClick={handleCancel}
            style={{
              padding: '10px 20px', border: '1px solid #e0e0e0', background: 'white', borderRadius: '8px',
              fontSize: '14px', fontWeight: '500', color: '#666', cursor: 'pointer', transition: 'all 0.2s ease',
              minWidth: '80px'
            }}
            onMouseEnter={(e) => { e.target.style.background = '#f8f9fa'; e.target.style.borderColor = '#ccc'; }}
            onMouseLeave={(e) => { e.target.style.background = 'white'; e.target.style.borderColor = '#e0e0e0'; }}
          >
            {cancelText}
          </button>
          <button
            onClick={handleConfirm}
            style={{
              padding: '10px 20px', border: 'none', background: buttonVariant.bg, color: buttonVariant.color,
              borderRadius: '8px', fontSize: '14px', fontWeight: '500', cursor: 'pointer', transition: 'all 0.2s ease',
              minWidth: '80px', boxShadow: '0 4px 14px rgba(255, 107, 107, 0.3)'
            }}
            onMouseEnter={(e) => {
              e.target.style.transform = 'translateY(-1px)';
              e.target.style.boxShadow = '0 6px 20px rgba(255, 107, 107, 0.4)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'translateY(0)';
              e.target.style.boxShadow = '0 4px 14px rgba(255, 107, 107, 0.3)';
            }}
          >
            {confirmText}
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
};

export default ConfirmModal;

// =========================================

src/components/modals/EditConnectionModal.jsx

import React, { useEffect, useMemo, useState } from "react";
import "../../css/NewConnectionModal.css"; // Â§çÁî®Áé∞ÊúâÊ†∑Âºè
import toast from "react-hot-toast";

const defaultPort = (dbType) => ({
  POSTGRESQL: "5432",
  MYSQL: "3306",
  SQLSERVER: "1433",
  ORACLE: "1521",
}[dbType] || "");

const rowStyle = { display: "flex", gap: 12, flexWrap: "wrap" };
const colStyle = { flex: "1 1 240px", minWidth: 240 };
const statusBox = (ok) => ({
  marginTop: 12,
  padding: "10px 12px",
  borderRadius: 8,
  fontSize: 13,
  lineHeight: 1.5,
  border: `1px solid ${ok ? "#16a34a30" : "#ef444430"}`,
  background: ok ? "#16a34a15" : "#ef44441a",
  color: ok ? "#065f46" : "#7f1d1d",
  display: "flex",
  alignItems: "flex-start",
  gap: 8,
});
const footerStyle = {
  position: "sticky",
  bottom: 0,
  background: "#fff",
  paddingTop: 12,
  marginTop: 12,
  borderTop: "1px solid #eee",
  display: "flex",
  gap: 8,
  justifyContent: "flex-end",
};

const EditConnectionModal = ({ isOpen, onClose, connection, onSubmit }) => {
  const [connectionData, setConnectionData] = useState({
    name: "",
    dbType: "POSTGRESQL",
    host: "localhost",
    port: "5432",
    database: "postgres",
    username: "",
    password: "",
    savePassword: false,
  });
  const [showPassword, setShowPassword] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState(null);
  const [isTesting, setIsTesting] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    if (isOpen && connection) {
      setConnectionData({
        name: connection.name || "",
        dbType: connection.dbType || "POSTGRESQL",
        host: connection.host || "localhost",
        port: String(connection.port || defaultPort(connection.dbType || "POSTGRESQL")),
        database: connection.database || "postgres",
        username: connection.username || "",
        password: "",
        savePassword: false,
      });
      setConnectionStatus(null);
    }
  }, [isOpen, connection]);

  const requiredOk = useMemo(() => {
    const { name, host, port, username } = connectionData;
    return !!name && !!host && !!port && !!username;
  }, [connectionData]);

  if (!isOpen) return null;

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setConnectionData((prev) => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value,
    }));
  };

  const normalizeHost = (host) => (host === "localhost" ? "127.0.0.1" : host);

  const handleTestConnection = async () => {
    setIsTesting(true);
    setConnectionStatus({ ok: null, msg: "Testing..." });
    try {
      const response = await fetch("/api/config/connections/test", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          id: connection.id,
          ...connectionData,
          host: normalizeHost(connectionData.host),
          port: parseInt(connectionData.port, 10),
          type: "connection",
        }),
      });
      const result = await response.json().catch(() => ({}));
      if (!response.ok) {
        const msg =
          result?.message ||
          "Connection failed. Please check host/port and DB service.";
        setConnectionStatus({ ok: false, msg });
        return;
      }
      setConnectionStatus({ ok: true, msg: "Connected successfully!" });
      toast.success("ËøûÊé•ÊµãËØïÊàêÂäü");
    } catch (error) {
      setConnectionStatus({
        ok: false,
        msg:
          error?.message ||
          "Connection failed. Check that the service is listening.",
      });
    } finally {
      setIsTesting(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!requiredOk) return;
    setIsSaving(true);
    try {
      const payload = {
        id: connection.id,
        ...connectionData,
        host: normalizeHost(connectionData.host),
        port: parseInt(connectionData.port, 10),
        type: "connection",
      };
      await onSubmit(payload);
      if (connectionData.savePassword) {
        localStorage.setItem(`savedPassword_${connection.id}`, connectionData.password);
      }
      onClose();
    } catch (error) {
      console.error(error)
    } finally {
      setIsSaving(false);
    }
  };

  const handleCancel = () => {
    setConnectionStatus(null);
    onClose();
  };

  return (
    <div className="modal-overlay" onClick={handleCancel}>
      <div
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        style={{ maxWidth: 680, width: "92%", maxHeight: "82vh", overflow: "auto" }}
      >
        <div
          style={{
            position: "sticky",
            top: 0,
            background: "#fff",
            paddingBottom: 10,
            marginBottom: 8,
            zIndex: 1,
          }}
        >
          <h2 className="modal-title" style={{ marginBottom: 0 }}>
            ÁºñËæëËøûÊé•
          </h2>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="form-section" style={{ paddingBottom: 0 }}>
            <div className="form-group">
              <label htmlFor="name">ËøûÊé•ÂêçÁß∞</label>
              <input
                type="text"
                id="name"
                name="name"
                value={connectionData.name}
                onChange={handleChange}
                placeholder="e.g., ÂºÄÂèëÁéØÂ¢É-deego"
                className="modal-input"
                autoFocus
              />
            </div>

            <div className="form-group">
              <label htmlFor="dbType">Êï∞ÊçÆÂ∫ìÁ±ªÂûã</label>
              <select
                id="dbType"
                name="dbType"
                value={connectionData.dbType}
                onChange={handleChange}
                className="modal-input"
              >
                <option value="POSTGRESQL">PostgreSQL</option>
                <option value="MYSQL">MySQL</option>
                <option value="SQLSERVER">SQL Server</option>
                <option value="ORACLE">Oracle</option>
              </select>
            </div>

            <div style={rowStyle}>
              <div className="form-group" style={colStyle}>
                <label htmlFor="host">‰∏ªÊú∫</label>
                <input
                  type="text"
                  id="host"
                  name="host"
                  value={connectionData.host}
                  onChange={handleChange}
                  placeholder="localhost / 127.0.0.1 / 192.168.x.x"
                  className="modal-input"
                />
              </div>
              <div className="form-group" style={{ ...colStyle, maxWidth: 200 }}>
                <label htmlFor="port">Á´ØÂè£</label>
                <input
                  type="number"
                  id="port"
                  name="port"
                  value={connectionData.port}
                  onChange={handleChange}
                  placeholder={defaultPort(connectionData.dbType)}
                  className="modal-input"
                  min="1"
                />
              </div>
            </div>

            <div className="form-group">
              <label htmlFor="database">Êï∞ÊçÆÂ∫ì</label>
              <input
                type="text"
                id="database"
                name="database"
                value={connectionData.database}
                onChange={handleChange}
                placeholder="postgres / db_name"
                className="modal-input"
              />
            </div>

            <div style={rowStyle}>
              <div className="form-group" style={colStyle}>
                <label htmlFor="username">Áî®Êà∑Âêç</label>
                <input
                  type="text"
                  id="username"
                  name="username"
                  value={connectionData.username}
                  onChange={handleChange}
                  placeholder="ËæìÂÖ•Áî®Êà∑Âêç"
                  className="modal-input"
                />
              </div>

              <div className="form-group" style={colStyle}>
                <label htmlFor="password">ÂØÜÁ†Å</label>
                <div className="password-wrapper">
                  <input
                    type={showPassword ? "text" : "password"}
                    id="password"
                    name="password"
                    value={connectionData.password}
                    onChange={handleChange}
                    placeholder="ÂèØÁïôÁ©∫"
                    className="modal-input"
                  />
                  <button
                    type="button"
                    className="toggle-password"
                    onClick={() => setShowPassword((v) => !v)}
                  >
                    {showPassword ? "ÈöêËóè" : "ÊòæÁ§∫"}
                  </button>
                </div>
              </div>
            </div>

            {connectionStatus && (
              <div style={statusBox(!!connectionStatus.ok)}>
                <span style={{ fontWeight: 700 }}>
                  {connectionStatus.ok === true ? "‚úì" : connectionStatus.ok === false ? "!" : "‚Ä¶" }
                </span>
                <span>{connectionStatus.msg}</span>
              </div>
            )}
          </div>

          <div style={footerStyle}>
            <button
              type="button"
              className="btn btn-secondary"
              onClick={handleTestConnection}
              disabled={isSaving || isTesting}
            >
              {isTesting ? "ÊµãËØï‰∏≠‚Ä¶" : "ÊµãËØïËøûÊé•"}
            </button>
            <button
              type="button"
              className="btn btn-cancel"
              onClick={handleCancel}
              disabled={isSaving}
            >
              ÂèñÊ∂à
            </button>
            <button
              type="submit"
              className="btn btn-primary"
              disabled={!requiredOk || isSaving || isTesting}
            >
              {isSaving ? "‰øùÂ≠ò‰∏≠‚Ä¶" : "‰øùÂ≠ò"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default EditConnectionModal;

// =========================================

src/components/modals/modalActions.js

import toast from 'react-hot-toast';
import { updateConnection } from '../../actions/dbActions';
import { useTreeStore } from '../../stores/useTreeStore';
import { actionHandlers } from '../../actions/dbActions';  // Êñ∞Â¢ûÂØºÂÖ•Âä®ÊÄÅ handler

// openNewGroup Êé•Êî∂ openModal ÂèÇÊï∞
export const openNewGroup = (parentId = null, openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  openModal('newGroup', { parentId });
};

// openNewConnection Êé•Êî∂ openModal ÂèÇÊï∞
export const openNewConnection = (parentId = null, openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  openModal('newConnection', { parentId });
};

// openConfirm Êé•Êî∂ openModal ÂèÇÊï∞
export const openConfirm = (title, message, onConfirm, variant = 'danger', openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  openModal('confirm', {
    title,
    message,
    onConfirm: async () => {
      try {
        await onConfirm();
      } catch (error) {
        toast.error('Êìç‰ΩúÂ§±Ë¥•');
        console.error('Confirm action error:', error);
      }
    },
    variant
  });
};

// openRenameFolder Êé•Êî∂ openModal ÂèÇÊï∞
export const openRenameFolder = (node, openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  openModal('renameFolder', {
    defaultName: node.name,
    onSubmit: async (newName) => {
      if (!newName || newName.trim() === '') {
        throw new Error('Êñá‰ª∂Â§πÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫');
      }
      try {
        const response = await fetch(`/api/config/folders`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newName.trim(), id: node.id , type: 'folder'})
        });
        if (!response.ok) throw new Error('Failed to rename folder');
        toast.success(`Êñá‰ª∂Â§πÂ∑≤ÈáçÂëΩÂêç‰∏∫ "${newName}"`);
      } catch (error) {
        toast.error('ÈáçÂëΩÂêçÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
        throw error; // ËÆ©Ê®°ÊÄÅÊ°ÜÂ§ÑÁêÜÈîôËØØ
      }
    }
  });
};

// openEditConnection Êé•Êî∂ openModal ÂèÇÊï∞Ôºå‰ΩøÁî® config
export const openEditConnection = (connection, openModal) => {
  if (typeof openModal !== 'function') {
    console.error('openModal must be a function');
    return;
  }
  openModal('editConnection', {
    connection,
    onSubmit: async (payload) => {
      const { updateTreePath } = useTreeStore.getState();
      await updateConnection(payload);
      // Êñ∞Â¢ûÔºöÊõ¥Êñ∞ÂêéÈáçÊñ∞Âä†ËΩΩ config
      await useTreeStore.getState().loadTreeConfig(payload.id);
    }
  });
};

// handleNewGroupSubmit Âíå handleNewConnectionSubmit ‰øùÊåÅÂéüÊ†∑ÔºàÁ∫Ø APIÔºâ
export const handleNewGroupSubmit = async (groupName, parentId) => {
  try {
    const response = await fetch('/api/config/folders', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: groupName, type: 'folder', parentId }),
    });
    if (!response.ok) throw new Error('Failed to create group');
    await response.json();
    toast.success('Êñ∞Âª∫ÂàÜÁªÑÊàêÂäü');
  } catch (err) {
    console.error('Error creating group:', err);
    toast.error('ÂàõÂª∫ÂàÜÁªÑÂ§±Ë¥•');
    throw err;
  }
};

export const handleNewConnectionSubmit = async (connectionData, parentId) => {
  try {
    const response = await fetch('/api/config/connections', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...connectionData, type: 'connection', parentId }),
    });
    if (!response.ok) throw new Error('Failed to create connection');
    await response.json();
    toast.success('Êñ∞Âª∫ËøûÊé•ÊàêÂäü');
  } catch (err) {
    console.error('Error creating connection:', err);
    toast.error('ÂàõÂª∫ËøûÊé•Â§±Ë¥•');
    throw err;
  }
};

// =========================================

src/components/modals/ModalProvider.jsx

import React, { createContext, useContext, useState } from 'react';
import { createPortal } from 'react-dom';
import ConfirmModal from './ConfirmModal';
import NewGroupModal from './NewGroupModal';
import NewConnectionModal from './NewConnectionModal';
import RenameFolderModal from './RenameFolderModal';
import EditConnectionModal from './EditConnectionModal';
import toast from 'react-hot-toast';

const ModalContext = createContext();

export const ModalProvider = ({ children }) => {
  const [modals, setModals] = useState({});

  const openModal = (type, config = {}) => {
    setModals((prev) => ({ ...prev, [type]: { isOpen: true, ...config } }));
  };

  const closeModal = (type) => {
    setModals((prev) => ({ ...prev, [type]: { ...prev[type], isOpen: false } }));
    // Âª∂ËøüÂÖ≥Èó≠‰ª•Âä®Áîª
    setTimeout(() => setModals((prev) => { const newModals = { ...prev }; delete newModals[type]; return newModals; }), 300);
  };

  const value = { openModal, closeModal };

  return (
    <ModalContext.Provider value={value}>
      {children}
      {createPortal(
        <>
          {modals.confirm && <ConfirmModal {...modals.confirm} onClose={() => closeModal('confirm')} />}
          {modals.newGroup && <NewGroupModal {...modals.newGroup} onClose={() => closeModal('newGroup')} />}
          {modals.newConnection && <NewConnectionModal {...modals.newConnection} onClose={() => closeModal('newConnection')} />}
          {modals.renameFolder && <RenameFolderModal {...modals.renameFolder} onClose={() => closeModal('renameFolder')} />}
          {modals.editConnection && <EditConnectionModal {...modals.editConnection} onClose={() => closeModal('editConnection')} />}
        </>,
        document.body
      )}
    </ModalContext.Provider>
  );
};

export const useModal = () => useContext(ModalContext);

// =========================================

src/components/modals/NewConnectionModal.jsx

import React, { useState, useEffect, useMemo } from "react";
import "../../css/NewConnectionModal.css"; // ‰øùÁïô‰Ω†Áé∞ÊúâÊ†∑Âºè
import toast from "react-hot-toast";
import { handleNewConnectionSubmit } from "../../actions/treeActions";

// Â∞èÂ∑•ÂÖ∑ÔºöÊ†πÊçÆ dbType ÁªôÂá∫ÈªòËÆ§Á´ØÂè£
const defaultPort = (dbType) => ({
  POSTGRESQL: "5432",
  MYSQL: "3306",
  SQLSERVER: "1433",
  ORACLE: "1521",
}[dbType] || "");

const rowStyle = { display: "flex", gap: 12, flexWrap: "wrap" };
const colStyle = { flex: "1 1 240px", minWidth: 240 };

const statusBox = (ok) => ({
  marginTop: 12,
  padding: "10px 12px",
  borderRadius: 8,
  fontSize: 13,
  lineHeight: 1.5,
  border: `1px solid ${ok ? "#16a34a30" : "#ef444430"}`,
  background: ok ? "#16a34a15" : "#ef44441a",
  color: ok ? "#065f46" : "#7f1d1d",
  display: "flex",
  alignItems: "flex-start",
  gap: 8,
});

const footerStyle = {
  position: "sticky",
  bottom: 0,
  background: "#fff",
  paddingTop: 12,
  marginTop: 12,
  borderTop: "1px solid #eee",
  display: "flex",
  gap: 8,
  justifyContent: "flex-end",
};

const NewConnectionModal = ({
  isOpen,
  onClose,
  parentId,
  onSubmit = handleNewConnectionSubmit,
}) => {
  const [connectionData, setConnectionData] = useState({
    name: "",
    dbType: "POSTGRESQL",
    host: "localhost",
    port: "5432",
    database: "postgres",
    username: "",
    password: "",
    savePassword: false,
  });
  const [showPassword, setShowPassword] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState(null); // { ok:boolean, msg:string }
  const [isTesting, setIsTesting] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    if (isOpen) setConnectionStatus(null);
  }, [isOpen]);

  // ÂàáÊç¢Êï∞ÊçÆÂ∫ìÁ±ªÂûãÊó∂ÔºåÊô∫ËÉΩÂ°´ÂÖÖÁ´ØÂè£Ôºà‰ªÖÂΩìÂΩìÂâçÁ´ØÂè£ÊòØÂÖ∂‰ªñÈªòËÆ§ÂÄºÊàñ‰∏∫Á©∫Êó∂Ôºâ
  useEffect(() => {
    setConnectionData((prev) => {
      const nextDefault = defaultPort(prev.dbType);
      const knownDefaults = ["5432", "3306", "1433", "1521", ""];
      if (knownDefaults.includes(prev.port)) {
        return { ...prev, port: nextDefault };
      }
      return prev;
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [connectionData.dbType]);

  const requiredOk = useMemo(() => {
    const { name, host, port, username } = connectionData;
    return !!name && !!host && !!port && !!username;
  }, [connectionData]);

  if (!isOpen) return null;

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setConnectionData((prev) => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value,
    }));
  };

  const normalizeHost = (host) => (host === "localhost" ? "127.0.0.1" : host);

  const handleTestConnection = async () => {
    setIsTesting(true);
    setConnectionStatus({ ok: null, msg: "Testing..." });
    try {
      const response = await fetch("/api/config/connections/test", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ...connectionData,
          host: normalizeHost(connectionData.host),
          port: parseInt(connectionData.port, 10),
          type: "connection",
        }),
      });
      const result = await response.json().catch(() => ({}));
      if (!response.ok) {
        const msg =
          result?.message ||
          "Connection failed. Please check host/port and DB service.";
        setConnectionStatus({ ok: false, msg });
        return;
      }
      setConnectionStatus({ ok: true, msg: "Connected successfully!" });
      toast.success("ËøûÊé•ÊµãËØïÊàêÂäü");
    } catch (error) {
      setConnectionStatus({
        ok: false,
        msg:
          error?.message ||
          "Connection failed. Check that the service is listening.",
      });
    } finally {
      setIsTesting(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!requiredOk) return;
    setIsSaving(true);
    try {
      const payload = {
        ...connectionData,
        host: normalizeHost(connectionData.host),
        port: parseInt(connectionData.port, 10),
        type: "connection",
        parentId,
      };
      await onSubmit(payload, parentId);
      if (connectionData.savePassword) {
        // ‰ªÖÁ§∫‰æãÔºåÁúüÂÆûÈ°πÁõÆÂª∫ËÆÆÂÆâÂÖ®Â≠òÂÇ®
        localStorage.setItem("savedPassword", connectionData.password);
      }
      toast.success("Êñ∞Âª∫ËøûÊé•ÊàêÂäü");
      onClose();
    } catch (error) {
      toast.error("Êñ∞Âª∫ËøûÊé•Â§±Ë¥•");
    } finally {
      setIsSaving(false);
    }
  };

  const handleCancel = () => {
    setConnectionData({
      name: "",
      dbType: "POSTGRESQL",
      host: "localhost",
      port: "5432",
      database: "postgres",
      username: "",
      password: "",
      savePassword: false,
    });
    setConnectionStatus(null);
    onClose();
  };

  return (
    <div className="modal-overlay" onClick={handleCancel}>
      <div
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        style={{ maxWidth: 680, width: "92%", maxHeight: "82vh", overflow: "auto" }}
      >
        <div
          style={{
            position: "sticky",
            top: 0,
            background: "#fff",
            paddingBottom: 10,
            marginBottom: 8,
            zIndex: 1,
          }}
        >
          <h2 className="modal-title" style={{ marginBottom: 0 }}>
            Êñ∞Âª∫ËøûÊé•
          </h2>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="form-section" style={{ paddingBottom: 0 }}>
            <div className="form-group">
              <label htmlFor="name">ËøûÊé•ÂêçÁß∞</label>
              <input
                type="text"
                id="name"
                name="name"
                value={connectionData.name}
                onChange={handleChange}
                placeholder="e.g., ÂºÄÂèëÁéØÂ¢É-deego"
                className="modal-input"
                autoFocus
              />
            </div>

            <div className="form-group">
              <label htmlFor="dbType">Êï∞ÊçÆÂ∫ìÁ±ªÂûã</label>
              <select
                id="dbType"
                name="dbType"
                value={connectionData.dbType}
                onChange={handleChange}
                className="modal-input"
              >
                <option value="POSTGRESQL">PostgreSQL</option>
                <option value="MYSQL">MySQL</option>
                <option value="SQLSERVER">SQL Server</option>
                <option value="ORACLE">Oracle</option>
              </select>
            </div>

            <div style={rowStyle}>
              <div className="form-group" style={colStyle}>
                <label htmlFor="host">‰∏ªÊú∫</label>
                <input
                  type="text"
                  id="host"
                  name="host"
                  value={connectionData.host}
                  onChange={handleChange}
                  placeholder="localhost / 127.0.0.1 / 192.168.x.x"
                  className="modal-input"
                />
              </div>
              <div className="form-group" style={{ ...colStyle, maxWidth: 200 }}>
                <label htmlFor="port">Á´ØÂè£</label>
                <input
                  type="number"
                  id="port"
                  name="port"
                  value={connectionData.port}
                  onChange={handleChange}
                  placeholder={defaultPort(connectionData.dbType)}
                  className="modal-input"
                  min="1"
                />
              </div>
            </div>

            <div className="form-group">
              <label htmlFor="database">Êï∞ÊçÆÂ∫ì</label>
              <input
                type="text"
                id="database"
                name="database"
                value={connectionData.database}
                onChange={handleChange}
                placeholder="postgres / db_name"
                className="modal-input"
              />
            </div>

            <div style={rowStyle}>
              <div className="form-group" style={colStyle}>
                <label htmlFor="username">Áî®Êà∑Âêç</label>
                <input
                  type="text"
                  id="username"
                  name="username"
                  value={connectionData.username}
                  onChange={handleChange}
                  placeholder="ËæìÂÖ•Áî®Êà∑Âêç"
                  className="modal-input"
                />
              </div>

              <div className="form-group" style={colStyle}>
                <label htmlFor="password">ÂØÜÁ†Å</label>
                <div className="password-wrapper">
                  <input
                    type={showPassword ? "text" : "password"}
                    id="password"
                    name="password"
                    value={connectionData.password}
                    onChange={handleChange}
                    placeholder="ÂèØÁïôÁ©∫"
                    className="modal-input"
                  />
                  <button
                    type="button"
                    className="toggle-password"
                    onClick={() => setShowPassword((v) => !v)}
                  >
                    {showPassword ? "ÈöêËóè" : "ÊòæÁ§∫"}
                  </button>
                </div>
              </div>
            </div>

            {connectionStatus && (
              <div style={statusBox(!!connectionStatus.ok)}>
                <span style={{ fontWeight: 700 }}>
                  {connectionStatus.ok === true ? "‚úì" : connectionStatus.ok === false ? "!" : "‚Ä¶" }
                </span>
                <span>{connectionStatus.msg}</span>
              </div>
            )}
          </div>

          <div style={footerStyle}>
            <button
              type="button"
              className="btn btn-secondary"
              onClick={handleTestConnection}
              disabled={isSaving || isTesting}
            >
              {isTesting ? "ÊµãËØï‰∏≠‚Ä¶" : "ÊµãËØïËøûÊé•"}
            </button>
            <button
              type="button"
              className="btn btn-cancel"
              onClick={handleCancel}
              disabled={isSaving}
            >
              ÂèñÊ∂à
            </button>
            <button
              type="submit"
              className="btn btn-primary"
              disabled={!requiredOk || isSaving || isTesting}
            >
              {isSaving ? "‰øùÂ≠ò‰∏≠‚Ä¶" : "‰øùÂ≠ò"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default NewConnectionModal;

// =========================================

src/components/modals/NewGroupModal.jsx

import React, { useState, useEffect } from "react";
import toast from 'react-hot-toast';
import { handleNewGroupSubmit } from '../../actions/treeActions'; // ÁßªÂà∞ actions

const NewGroupModal = ({ isOpen, onClose, parentId, onSubmit = handleNewGroupSubmit }) => {
  const [groupName, setGroupName] = useState("");
  const [error, setError] = useState(null);

  useEffect(() => {
    if (isOpen) {
      setGroupName("");
      setError(null);
    }
  }, [isOpen]);

  if (!isOpen) return null;

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!groupName.trim()) {
      setError("Êñá‰ª∂Â§πÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫");
      return;
    }
    try {
      await onSubmit(groupName, parentId);
      toast.success('Êñ∞Âª∫ÂàÜÁªÑÊàêÂäü');
      onClose();
    } catch (err) {
      setError("ÂàõÂª∫ÂàÜÁªÑÂ§±Ë¥•ÔºåËØ∑ÈáçËØï„ÄÇ");
      toast.error('ÂàõÂª∫Â§±Ë¥•');
    }
  };

  const handleCancel = () => {
    setGroupName("");
    setError(null);
    onClose();
  };

  return (
    <div className="modal-overlay" onClick={handleCancel}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <h2 className="modal-title">Êñ∞Âª∫ÂàÜÁªÑ</h2>
        {error && <div className="error-message">{error}</div>}
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="groupName">ÂàÜÁªÑÂêçÁß∞</label>
            <input
              type="text"
              id="groupName"
              value={groupName}
              onChange={(e) => setGroupName(e.target.value)}
              placeholder="ËæìÂÖ•ÂàÜÁªÑÂêçÁß∞"
              className="modal-input"
              autoFocus
            />
          </div>
          <div className="modal-actions">
            <button type="button" className="btn btn-cancel" onClick={handleCancel}>ÂèñÊ∂à</button>
            <button type="submit" className="btn btn-primary" disabled={!groupName.trim()}>Á°ÆËÆ§</button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default NewGroupModal;

// =========================================

src/components/modals/RenameFolderModal.jsx

import React, { useState, useEffect } from "react";
import '../../css/NewGroupModal.css'; // Â§çÁî®Ê†∑Âºè
import toast from 'react-hot-toast';

const RenameFolderModal = ({ isOpen, onClose, parentId, defaultName = "", onSubmit }) => {
  const [groupName, setGroupName] = useState(defaultName || "");
  const [error, setError] = useState(null);

  useEffect(() => {
    if (isOpen) {
      setGroupName(defaultName || "");
      setError(null);
    }
  }, [defaultName, isOpen]);

  if (!isOpen) return null;

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!groupName.trim()) {
      setError("Êñá‰ª∂Â§πÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫");
      return;
    }

    try {
      await onSubmit(groupName, parentId);
      toast.success("ÈáçÂëΩÂêçÊàêÂäü");
      setGroupName("");
      onClose();
    } catch (err) {
      console.error("Error renaming folder:", err);
      setError("ÈáçÂëΩÂêçÊñá‰ª∂Â§πÂ§±Ë¥•ÔºåËØ∑ÈáçËØï„ÄÇ");
      toast.error("ÈáçÂëΩÂêçÂ§±Ë¥•");
    }
  };

  const handleCancel = () => {
    setGroupName(defaultName || "");
    setError(null);
    onClose();
  };

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <h2 className="modal-title">ÈáçÂëΩÂêçÊñá‰ª∂Â§π</h2>
        {error && <div className="error-message">{error}</div>}
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="groupName">Êñá‰ª∂Â§πÂêçÁß∞</label>
            <input
              type="text"
              id="groupName"
              value={groupName}
              onChange={(e) => setGroupName(e.target.value)}
              placeholder="ËæìÂÖ•Êñá‰ª∂Â§πÂêçÁß∞"
              className="modal-input"
              autoFocus
            />
          </div>
          <div className="modal-actions">
            <button
              type="button"
              className="btn btn-cancel"
              onClick={handleCancel}
            >
              ÂèñÊ∂à
            </button>
            <button
              type="submit"
              className="btn btn-primary"
              disabled={!groupName.trim()}
            >
              Á°ÆËÆ§
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default RenameFolderModal;

// =========================================

src/components/ResultTable.jsx

// \frontend\src\components\ResultTable.jsx
import React from 'react'

export default function ResultTable({ data }) {
  if (!data || data.length === 0) {
    return <div className="result-table">No results</div>
  }
  const cols = Object.keys(data[0])
  return (
    <div className="result-table">
      <table>
        <thead>
          <tr>
            {cols.map(c => <th key={c}>{c}</th>)}
          </tr>
        </thead>
        <tbody>
          {data.map((row, i) => (
            <tr key={i}>
              {cols.map(col => <td key={col + i}>{String(row[col] ?? '')}</td>)}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}

// =========================================

src/components/sidebar/hooks/useDragDrop.js

import { useState, useEffect } from 'react';
import { moveNode } from '../../../actions/treeActions';

export const useDragDrop = () => {
  const [dragSourceId, setDragSourceId] = useState(null);
  const [dragOverNodeId, setDragOverNodeId] = useState(null);
  const [isDragOverRoot, setIsDragOverRoot] = useState(false);

  useEffect(() => {
    const handleDragEnd = () => {
      setTimeout(() => {
        setDragSourceId(null);
        setDragOverNodeId(null);
        setIsDragOverRoot(false);
      }, 100);
    };
    document.addEventListener('dragend', handleDragEnd);
    return () => document.removeEventListener('dragend', handleDragEnd);
  }, []);

  return {
    dragSourceId, setDragSourceId, dragOverNodeId, setDragOverNodeId, isDragOverRoot, setIsDragOverRoot
  };
};

// =========================================

src/components/sidebar/MoreActionsMenu.jsx

import React, { useState } from 'react';
import { getAllActions } from '../../actions/dbActions';
import toast from 'react-hot-toast';

const MoreActionsMenu = ({
  node,
  position,
  onClose,
  setExpandedKeys,
  openNewGroup,
  openNewConnection,
  openConfirm,
  openRenameFolder,
  openEditConnection,
  refreshFolder,
  deleteFolder,
  refreshConnection,
  connectDatabase,
  disconnectDatabase,
  refreshDatabase,
  refreshSchema,
  createNewSchema,
  exportDatabase,
  createNewTable,
  exportSchema,
  previewTable,
  editTableStructure,
  generateTableSQL,
  exportTableData,
  viewDefinition,
  editView,
  generateViewSQL,
  editFunction,
  viewFunctionSource,
  testFunction,
  showProperties,
  deleteConnection,
  deleteDatabase,
  deleteSchema,
  deleteTable,
  deleteView,
  deleteFunction
}) => {
  const [hoveredItem, setHoveredItem] = useState(null);
  // ‰øÆÂ§çÔºö‰º†ÂÖ•ÊâÄÊúâÂøÖË¶Å props Âà∞ getAllActions
  const actions = getAllActions(node.type, node, setExpandedKeys, openNewGroup, openNewConnection, openConfirm, openRenameFolder, openEditConnection, refreshFolder, deleteFolder, refreshConnection, connectDatabase, disconnectDatabase, refreshDatabase, refreshSchema, createNewSchema, exportDatabase, createNewTable, exportSchema, previewTable, editTableStructure, generateTableSQL, exportTableData, viewDefinition, editView, generateViewSQL, editFunction, viewFunctionSource, testFunction, showProperties, deleteConnection, deleteDatabase, deleteSchema, deleteTable, deleteView, deleteFunction);

  const handleAction = (action) => {
    try {
      if (typeof action === 'function') {
        action();
      } else {
        toast.error('Êó†ÊïàÊìç‰Ωú');
      }
    } catch (error) {
      console.error('Action error:', error);
      toast.error('Êìç‰ΩúÊâßË°åÂ§±Ë¥•');
    }
    onClose();
  };

  const flipStyle = position.flip ? {
    borderTop: '2px solid #e0e0e0',
    borderBottom: '1px solid #e0e0e0'
  } : {};

  return (
    <div
      className="more-actions-menu"
      style={{
        position: 'fixed',
        left: position.x,
        top: position.y,
        background: 'white',
        border: '1px solid #e0e0e0',
        borderRadius: '8px',
        boxShadow: '0 8px 32px rgba(0,0,0,0.12)',
        zIndex: 1000,
        minWidth: '180px',
        maxHeight: '300px',
        overflowY: 'auto',
        fontSize: '13px',
        fontFamily: 'var(--font)',
        ...flipStyle
      }}
    >
      {actions.map((item, index) => {
        if (item.type === 'separator') {
          return (
            <div
              key={`sep-${index}`}
              style={{
                height: '1px',
                background: '#e0e0e0',
                margin: '4px 0'
              }}
            />
          );
        }

        const isHovered = hoveredItem === index;
        return (
          <div
            key={item.label}
            style={{
              padding: '10px 16px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '10px',
              color: isHovered ? '#0b69ff' : '#333',
              background: isHovered ? '#f8f9fa' : 'transparent',
              transition: 'all 0.2s ease',
              borderRadius: '6px',
              margin: '2px 4px'
            }}
            onMouseEnter={() => setHoveredItem(index)}
            onMouseLeave={() => setHoveredItem(null)}
            onClick={(e) => {
              e.stopPropagation();
              handleAction(item.action);
            }}
          >
            <span style={{ fontSize: '14px', width: '16px' }}>{item.icon}</span>
            <span style={{ flex: 1 }}>{item.label}</span>
          </div>
        );
      })}
    </div>
  );
};

export default MoreActionsMenu;

// =========================================

src/components/sidebar/Sidebar.jsx

import React, { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import TreeContainer from './TreeContainer';
import MoreActionsMenu from './MoreActionsMenu';
import deegoLogo from '../../public/icons/deego_1.svg';
import { useTreeStore } from '../../stores/useTreeStore';
import { useModal } from '../modals/ModalProvider';
import { openNewGroup, openNewConnection, openConfirm, openRenameFolder, openEditConnection } from '../modals/modalActions';
import { refreshFolder, deleteFolder } from '../../actions/treeActions';
import { connectDatabase, disconnectDatabase, refreshConnection, deleteConnection, refreshDatabase, refreshSchema, createNewSchema, exportDatabase, createNewTable, exportSchema, previewTable, editTableStructure, generateTableSQL, exportTableData, viewDefinition, editView, generateViewSQL, editFunction, viewFunctionSource, testFunction, showProperties, deleteDatabase, deleteSchema, deleteTable, deleteView, deleteFunction } from '../../actions/dbActions';
import { useDragDrop } from './hooks/useDragDrop';
import { findNode } from '../../utils/treeUtils';

const Sidebar = ({ treeData }) => {
  const [expandedKeys, setExpandedKeys] = useState(new Map());
  const [showMoreMenu, setShowMoreMenu] = useState(null);
  const [moreMenuPosition, setMoreMenuPosition] = useState({ x: 0, y: 0, flip: false });
  const [activeMoreMenuNode, setActiveMoreMenuNode] = useState(null);
  const [hoveredNode, setHoveredNode] = useState(null);
  const { openModal } = useModal();
  const { dragSourceId, setDragSourceId, dragOverNodeId, setDragOverNodeId, isDragOverRoot, setIsDragOverRoot } = useDragDrop();
  const updateTreePath = useTreeStore((state) => state.updateTreePath);

  // Â§ñÈÉ®ÁÇπÂáªÂÖ≥Èó≠ËèúÂçïÔºö‰∏çÂèò
  useEffect(() => {
    if (!showMoreMenu) return;
    const handleClickOutside = (event) => {
      if (!event.target.closest('.more-actions-menu') && !event.target.closest('.tree-node')) {
        setShowMoreMenu(null);
        setMoreMenuPosition({ x: 0, y: 0, flip: false });
        setActiveMoreMenuNode(null);
      }
    };
    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, [showMoreMenu]);

  useEffect(() => {
    if (!showMoreMenu) return;
    const onKey = (e) => { if (e.key === 'Escape') { setShowMoreMenu(null); setActiveMoreMenuNode(null); setMoreMenuPosition({ x: 0, y: 0, flip: false });} };
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [showMoreMenu]);

  useEffect(() => {
    if (!showMoreMenu) return;
    const close = () => { setShowMoreMenu(null); setActiveMoreMenuNode(null); setMoreMenuPosition({ x: 0, y: 0, flip: false });};
    window.addEventListener('scroll', close, true);
    window.addEventListener('resize', close);
    return () => {
      window.removeEventListener('scroll', close, true);
      window.removeEventListener('resize', close);
    };
  }, [showMoreMenu]);

  const handleMoreMenu = (e, node) => {
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    const baseY = rect.bottom;
    const estimatedMenuHeight = 200;
    const viewportHeight = window.innerHeight;
    const spaceBelow = viewportHeight - baseY;
    const minTop = 20;
    const bottomMargin = 20;

    let flip = false;
    let adjustedY = baseY + 10;

    if (spaceBelow >= estimatedMenuHeight) {
      adjustedY = baseY + 10;
    } else {
      flip = true;
      adjustedY = rect.top - estimatedMenuHeight;
      if (adjustedY < minTop) {
        adjustedY = minTop;
      }
    }

    if (adjustedY + estimatedMenuHeight > viewportHeight - bottomMargin) {
      adjustedY = viewportHeight - estimatedMenuHeight - bottomMargin;
      flip = adjustedY < rect.top;
    }

    setMoreMenuPosition({ x: e.clientX + 5, y: adjustedY, flip });
    setShowMoreMenu(node.id);
    setActiveMoreMenuNode(node.id);
  };

  const openRenameFolderModal = (node) => openRenameFolder(node, openModal);
  const openEditConnectionModal = (connection) => openEditConnection(connection, openModal);

  const renderMoreMenuPortal = () => {
    if (!showMoreMenu || !treeData) return null;
    const node = findNode(treeData, showMoreMenu);
    if (!node) return null;
    return createPortal(
      <MoreActionsMenu
        node={node}
        position={moreMenuPosition}
        onClose={() => { setShowMoreMenu(null); setActiveMoreMenuNode(null); }}
        setExpandedKeys={setExpandedKeys}
        openNewGroup={(parentId) => openNewGroup(parentId, openModal)}
        openNewConnection={(parentId) => openNewConnection(parentId, openModal)}
        openConfirm={(title, message, onConfirm, variant) => openConfirm(title, message, onConfirm, variant, openModal)}
        openRenameFolder={openRenameFolderModal}
        openEditConnection={openEditConnectionModal}
        refreshFolder={(node) => refreshFolder(node)}
        deleteFolder={(node) => deleteFolder(node, openModal)}
        refreshConnection={(node, setExpandedKeys) => refreshConnection(node, setExpandedKeys)}
        connectDatabase={(node) => connectDatabase(node)}  // Â∑≤ÈõÜÊàêÈÖçÁΩÆÂä†ËΩΩ
        disconnectDatabase={(node) => disconnectDatabase(node)}
        refreshDatabase={(node, setExpandedKeys) => refreshDatabase(node, setExpandedKeys)}
        refreshSchema={(node, setExpandedKeys) => refreshSchema(node, setExpandedKeys)}
        createNewSchema={(node) => createNewSchema(node)}
        exportDatabase={(node) => exportDatabase(node)}
        createNewTable={(node) => createNewTable(node)}
        exportSchema={(node) => exportSchema(node)}
        previewTable={(node) => previewTable(node)}
        editTableStructure={(node) => editTableStructure(node)}
        generateTableSQL={(node) => generateTableSQL(node)}
        exportTableData={(node) => exportTableData(node)}
        viewDefinition={(node) => viewDefinition(node)}
        editView={(node) => editView(node)}
        generateViewSQL={(node) => generateViewSQL(node)}
        editFunction={(node) => editFunction(node)}
        viewFunctionSource={(node) => viewFunctionSource(node)}
        testFunction={(node) => testFunction(node)}
        showProperties={(node) => showProperties(node)}
        deleteConnection={(node) => deleteConnection(node, openModal)}
        deleteDatabase={(node) => deleteDatabase(node, openModal)}
        deleteSchema={(node) => deleteSchema(node, openModal)}
        deleteTable={(node) => deleteTable(node, openModal)}
        deleteView={(node) => deleteView(node, openModal)}
        deleteFunction={(node) => deleteFunction(node, openModal)}
      />,
      document.body
    );
  };

  return (
    <>
      <div className="sidebar-tree">
        <div style={{ padding: '0 16px', marginBottom: '20px' }}>
          <div
            style={{
              display: 'flex', alignItems: 'center', gap: '8px', padding: '12px 16px',
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', borderRadius: '10px',
              boxShadow: '0 4px 14px rgba(102, 126, 234, 0.2)', marginBottom: '16px', color: 'white',
              transition: 'all 0.3s ease', cursor: 'pointer'
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.transform = 'translateY(-2px)';
              e.currentTarget.style.boxShadow = '0 6px 20px rgba(102, 126, 234, 0.3)';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.transform = 'translateY(0)';
              e.currentTarget.style.boxShadow = '0 4px 14px rgba(102, 126, 234, 0.2)';
            }}
            onClick={() => console.log('ÊâìÂºÄÊï∞ÊçÆÂ∫ìËÆæÁΩÆ')}
          >
            <img src={deegoLogo} alt="Deego" style={{ width: 25, height: 25, filter: 'brightness(0) invert(1)' }} />
            <div>
              <div style={{ fontSize: '14px', fontWeight: '600' }}>Deego</div>
              <div style={{ fontSize: '11px', opacity: 0.9, marginTop: '2px' }}>Your Data Buddy</div>
            </div>
          </div>
        </div>
        <TreeContainer
          treeData={treeData}
          expandedKeys={expandedKeys}
          setExpandedKeys={setExpandedKeys}
          hoveredNode={hoveredNode}
          setHoveredNode={setHoveredNode}
          onMoreMenu={handleMoreMenu}
          activeMoreMenuNode={activeMoreMenuNode}
          setActiveMoreMenuNode={setActiveMoreMenuNode}
          dragSourceId={dragSourceId}
          setDragSourceId={setDragSourceId}
          dragOverNodeId={dragOverNodeId}
          setDragOverNodeId={setDragOverNodeId}
          isDragOverRoot={isDragOverRoot}
          setIsDragOverRoot={setIsDragOverRoot}
          openNewGroup={(parentId) => openNewGroup(parentId, openModal)}
          openNewConnection={(parentId) => openNewConnection(parentId, openModal)}
          openRenameFolder={(node) => openRenameFolder(node, openModal)}
          openEditConnection={(connection) => openEditConnection(connection, openModal)}
          openModal={openModal}
        />
      </div>
      {renderMoreMenuPortal()}
    </>
  );
};

export default Sidebar;

// =========================================

src/components/sidebar/styles.js

// components/sidebar/styles.js
// Ê†∑ÂºèÂíå‰∏ªÈ¢òÈÖçÁΩÆ

const ACCENT_COLOR = '#0b69ff';

// Êñ∞Â¢ûÔºöÊãñÊãΩÈ´ò‰∫ÆÊ†∑Âºè
export const dragOverStyles = (theme) => ({
  background: `${theme.hoverBg} !important`,
  border: `2px dashed ${theme.accentColor} !important`,
  opacity: 0.8,
  transform: 'scale(1.02)',
  boxShadow: `0 2px 8px ${theme.accentColor}20 !important`
});

// Êñ∞Â¢ûÔºöÊãñÊãΩÊ∫êÊ†∑Âºè
export const dragSourceStyles = {
  opacity: 0.5,
  transform: 'rotate(5deg)',
  boxShadow: '0 4px 12px rgba(0,0,0,0.2)'
};

// ËäÇÁÇπ‰∏ªÈ¢òÈÖçÁΩÆ
export const getThemeColors = (nodeType) => {
  switch (nodeType) {
    case 'folder':
      return {
        hoverBg: 'linear-gradient(90deg, #f8f9ff 0%, #f0f2ff 100%)',
        textColor: '#5b6d8f',
        iconColor: '#667eea',
        accentColor: ACCENT_COLOR
      };
    case 'connection':
      return {
        hoverBg: `linear-gradient(90deg, rgba(11, 105, 255, 0.05) 0%, rgba(11, 105, 255, 0.1) 100%)`,
        textColor: '#2e7d32',
        iconColor: '#4caf50',
        accentColor: ACCENT_COLOR
      };
    case 'database': // Êñ∞Â¢ûÔºödatabase ‰∏ìÂ±û‰∏ªÈ¢òÔºàËìùËâ≤Ë∞ÉÔºâ
        return {
          hoverBg: 'linear-gradient(90deg, #e3f2fd 0%, #bbdefb 100%)',
          textColor: '#1976d2',
          iconColor: '#2196f3',
          accentColor: ACCENT_COLOR
        };
    case 'schema':
      return {
        hoverBg: 'linear-gradient(90deg, #fff3e0 0%, #ffecb3 100%)',
        textColor: '#e65100',
        iconColor: '#ff9800',
        accentColor: ACCENT_COLOR
      };
    case 'table':
      return {
        hoverBg: 'linear-gradient(90deg, #f3e5f5 0%, #f1e8fd 100%)',
        textColor: '#6a1b9a',
        iconColor: '#9c27b0',
        accentColor: ACCENT_COLOR
      };
    default:
      return {
        hoverBg: '#f5f5f5',
        textColor: '#333',
        iconColor: '#666',
        accentColor: ACCENT_COLOR
      };
  }
};

// ËäÇÁÇπÂü∫Á°ÄÊ†∑Âºè
export const nodeBaseStyles = {
  padding: '6px 8px',
  margin: '1px 0',
  display: 'flex',
  alignItems: 'center',
  borderRadius: '6px',
  cursor: 'pointer',
  transition: 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, transform 0.3s ease',
  fontFamily: 'var(--font)',
  fontSize: '13px'
};

// ÊÇ¨ÊµÆÊó∂ÁöÑÂü∫Á°ÄÊ†∑Âºè
export const nodeHoverStyles = (theme) => ({
  background: theme.hoverBg,
  border: `1px solid ${theme.accentColor}20`,
  transform: 'translateX(1px)',
  boxShadow: `0 1px 4px ${theme.accentColor}10`,
  paddingRight: '4px'
});

// Â±ïÂºÄÂõæÊ†áÊ†∑Âºè
export const expandIconStyles = (isHovered, theme) => ({
  width: 12,
  height: 12,
  marginRight: 4,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  transition: 'all 0.2s ease',
  transform: isHovered ? 'scale(1.05)' : 'scale(1)',
  color: isHovered ? theme.accentColor : '#999'
});

// ËäÇÁÇπÂõæÊ†áÊ†∑Âºè
export const nodeIconStyles = (isHovered, theme) => ({
  width: 14,
  height: 14,
  marginRight: 4,
  flexShrink: 0,
  filter: isHovered ? `drop-shadow(0 0 1px ${theme.accentColor}30)` : 'none',
  transition: 'all 0.2s ease',
  transform: isHovered ? 'scale(1.02)' : 'scale(1)'
});

// ËäÇÁÇπÂêçÁß∞Ê†∑Âºè
export const nodeNameStyles = (isHovered) => ({
  flex: 1,
  fontSize: isHovered ? '13.2px' : '13px',
  fontWeight: isHovered ? '500' : '400',
  color: isHovered ? '#333' : '#333', // ËøôÈáåÂèØ‰ª•Ê†πÊçÆtheme.textColorÂä®ÊÄÅËÆæÁΩÆ
  whiteSpace: 'nowrap',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  transition: 'all 0.2s ease',
  letterSpacing: isHovered ? '0.1px' : '0px',
  marginRight: isHovered ? '8px' : '0'
});

// Á±ªÂûãÊ†áÁ≠æÊ†∑Âºè
export const typeLabelStyles = (isHovered, theme) => ({
  fontSize: '10px',
  color: isHovered ? theme.accentColor : '#999',
  background: isHovered ? `${theme.accentColor}10` : '#f0f0f0',
  padding: isHovered ? '2px 6px' : '1px 4px',
  borderRadius: '10px',
  border: isHovered ? `1px solid ${theme.accentColor}20` : 'none',
  transition: 'all 0.2s ease',
  transform: isHovered ? 'scale(1.02)' : 'scale(1)',
  whiteSpace: 'nowrap',
  flexShrink: 0,
  marginLeft: '4px'
});

// ÂäüËÉΩÊåâÈíÆÊ†∑Âºè
export const actionButtonStyles = (theme) => ({
  width: 20,
  height: 20,
  border: 'none',
  background: 'rgba(255, 255, 255, 0.8)',
  borderRadius: '4px',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  cursor: 'pointer',
  color: theme.accentColor,
  fontSize: '12px',
  transition: 'all 0.2s ease',
  boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
  flexShrink: 0
});

// Êõ¥Â§öÊåâÈíÆÊ†∑Âºè
export const moreButtonStyles = (isHovered, theme) => ({
  ...actionButtonStyles(theme),
  color: isHovered ? theme.accentColor : '#666',
  background: isHovered ? 'white' : 'rgba(255, 255, 255, 0.8)',
  transform: isHovered ? 'scale(1.05)' : 'scale(1)',
  boxShadow: isHovered ? '0 2px 6px rgba(0, 0, 0, 0.15)' : '0 1px 3px rgba(0, 0, 0, 0.1)'
});

// Â∑¶‰æßÊåáÁ§∫Êù°Ê†∑Âºè
export const indicatorBarStyles = (theme) => ({
  position: 'absolute',
  left: 0,
  top: 0,
  bottom: 0,
  width: '2px',
  background: `linear-gradient(to bottom, ${theme.accentColor}, ${theme.accentColor}80)`,
  borderRadius: '0 2px 2px 0'
});

// Â≠êÈ°πÊåáÁ§∫Âô®Ê†∑Âºè
export const childIndicatorStyles = (theme) => ({
  position: 'absolute',
  right: 6,
  top: '50%',
  transform: 'translateY(-50%)',
  width: 3,
  height: 3,
  background: theme.accentColor,
  borderRadius: '50%',
  opacity: 0.6
});

// ÊåâÈíÆÂÆπÂô®Ê†∑Âºè
export const actionContainerStyles = {
  display: 'flex',
  alignItems: 'center',
  gap: '2px',
  marginLeft: '4px',
  paddingLeft: '2px'
};

// =========================================

src/components/sidebar/TreeContainer.jsx

import React, { useMemo } from 'react';
import TreeNode from './TreeNode';
import { findNode } from '../../utils/treeUtils';
import { moveNode } from '../../actions/treeActions';
import { useTreeStore } from '../../stores/useTreeStore';

const TreeContainer = ({
  treeData, expandedKeys, setExpandedKeys, hoveredNode, setHoveredNode,
  onMoreMenu, activeMoreMenuNode, setActiveMoreMenuNode,
  dragSourceId, setDragSourceId, dragOverNodeId, setDragOverNodeId,
  isDragOverRoot, setIsDragOverRoot,
  openNewGroup, openNewConnection, openRenameFolder, openEditConnection,
  openModal  // Êé•Êî∂ openModal
}) => {
  const { updateTreePath } = useTreeStore();

  const handleMoveNode = (sourceId, targetId) => {
    const sourceNode = findNode(treeData, sourceId);
    const actualType = sourceNode?.config?.type || sourceNode?.type || 'unknown';  // config fallback
    if (sourceNode && (actualType === 'folder' || actualType === 'connection')) {
      moveNode(sourceId, targetId, updateTreePath, openModal, actualType);
    }
  };

  const renderTreeNodes = useMemo(() => (nodes, level = 0) => {
    if (!nodes || nodes.length === 0) {
      return <div style={{ padding: '20px', textAlign: 'center', color: '#999', fontSize: '14px' }}>Êó†Êï∞ÊçÆ</div>;
    }
    return nodes.map((node) => {
      const isExpanded = expandedKeys.get(node.id) || false;
      const renderedNode = (
        <TreeNode
          key={node.id}
          node={{ ...node, expanded: isExpanded }}
          level={level}
          hoveredNode={hoveredNode}
          setHoveredNode={setHoveredNode}
          expandedKeys={expandedKeys}
          setExpandedKeys={setExpandedKeys}
          onMoreMenu={onMoreMenu}
          activeMoreMenuNode={activeMoreMenuNode}
          setActiveMoreMenuNode={setActiveMoreMenuNode}
          dragSourceId={dragSourceId}
          setDragSourceId={setDragSourceId}
          dragOverNodeId={dragOverNodeId}
          setDragOverNodeId={setDragOverNodeId}
          moveNode={handleMoveNode}
          openNewGroup={openNewGroup}
          openNewConnection={openNewConnection}
          openRenameFolder={openRenameFolder}
          openEditConnection={openEditConnection}
        />
      );

      if (isExpanded && node.children && node.children.length > 0) {
        return (
          <React.Fragment key={node.id}>
            {renderedNode}
            <div
              style={{ marginLeft: '2px', paddingLeft: '1px', borderLeft: '1px solid #e0e7ff', marginTop: '1px' }}
              onDragOver={(e) => {
                e.preventDefault();
                if (dragSourceId && dragSourceId !== node.id && (node.type === 'folder' || node.config?.allowDrop)) setDragOverNodeId(node.id);
              }}
              onDragLeave={() => setDragOverNodeId(null)}
              onDrop={(e) => {
                e.preventDefault();
                if (dragSourceId && dragSourceId !== node.id && (node.type === 'folder' || node.config?.allowDrop)) handleMoveNode(dragSourceId, node.id);
                setDragOverNodeId(null);
              }}
            >
              {renderTreeNodes(node.children, level + 1)}
            </div>
          </React.Fragment>
        );
      }
      return renderedNode;
    });
  }, [treeData, expandedKeys, hoveredNode, activeMoreMenuNode, dragSourceId, dragOverNodeId, handleMoveNode, openNewGroup, openNewConnection, openRenameFolder, openEditConnection]);

  const handleRootDrop = (e) => {
    e.preventDefault();
    setIsDragOverRoot(false);
    if (dragSourceId) handleMoveNode(dragSourceId, null);
  };

  const handleRootDragOver = (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    setIsDragOverRoot(true);
  };

  const rootContainerStyle = {
    minHeight: '20px', padding: '0 16px', transition: 'all 0.2s ease',
    border: isDragOverRoot ? '2px dashed #0b69ff' : 'none',
    background: isDragOverRoot ? '#f8f9fa' : 'transparent',
    borderRadius: '4px', margin: '0 4px'
  };

  return (
    <div
      className="tree-container"
      style={rootContainerStyle}
      onDragOver={handleRootDragOver}
      onDragLeave={() => setIsDragOverRoot(false)}
      onDrop={handleRootDrop}
    >
      {renderTreeNodes(treeData)}
    </div>
  );
};

export default TreeContainer;

// =========================================

src/components/sidebar/TreeNode.jsx

import React, { useState, memo, useMemo } from 'react';
import { useTreeStore } from '../../stores/useTreeStore';
import {
  getExpandIcon,
  getNodeIcon,
  loadNodeChildren
} from '../../utils/treeUtils';
import { getPrimaryAction } from '../../actions/dbActions';
import {
  getThemeColors,
  nodeBaseStyles,
  nodeHoverStyles,
  expandIconStyles,
  nodeIconStyles,
  nodeNameStyles,
  typeLabelStyles,
  actionButtonStyles,
  indicatorBarStyles,
  childIndicatorStyles,
  actionContainerStyles,
  dragOverStyles,
  dragSourceStyles
} from './styles';

const TreeNode = memo(({
  node,
  level = 0,
  hoveredNode,
  setHoveredNode,
  expandedKeys,
  setExpandedKeys,
  onMoreMenu,
  activeMoreMenuNode,
  setActiveMoreMenuNode,
  dragSourceId,
  setDragSourceId,
  dragOverNodeId,
  setDragOverNodeId,
  moveNode,
  openNewGroup,
  openNewConnection,
  openRenameFolder,
  openEditConnection
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const isHovered = hoveredNode === node.id;
  const isActive = activeMoreMenuNode === node.id;
  const isDragging = dragSourceId === node.id;
  const isDragOver = dragOverNodeId === node.id;
  const hasChildren = node.children && node.children.length > 0;
  const isExpandable = hasChildren || node.config?.nextLevel || node.virtual || node.type === 'connection' || node.type === 'database' || node.type === 'schema' || node.type.includes('_group');
  const isDraggable = node.type === 'folder' || node.type === 'connection';
  const isDropTarget = node.type === 'folder' || node.config?.allowDrop;  // config ÊîØÊåÅ
  const primaryAction = getPrimaryAction(node);  // ‰ΩøÁî® config
  const theme = getThemeColors(node.type || node.config?.type);  // config.type fallback
  const { updateTreePath } = useTreeStore();
  const isExpanded = node.expanded;
  const isConnected = node.connected;
  if (isConnected) theme.accentColor = '#10b981';

  // useMemo ‰ºòÂåñÔºö‰ªÖÂú®ÂøÖË¶ÅÊó∂ÈáçÊñ∞ËÆ°ÁÆóÊ†∑Âºè
  const combinedStyles = useMemo(() => ({
    ...nodeBaseStyles,
    ...(isDragging && dragSourceStyles),
    ...(isDragOver && dragOverStyles(theme)),
    paddingLeft: `${12 + level * 12}px`,
    cursor: isDraggable ? 'grab' : (isExpandable ? 'pointer' : (isLoading ? 'wait' : 'default')),
    background: (isDragging ? 'transparent' : ((isHovered || isActive) ? theme.hoverBg : 'transparent')),
    border: (isDragOver ? `2px dashed ${theme.accentColor}` : ((isHovered || isActive) ? `1px solid ${theme.accentColor}20` : (isConnected ? `1px solid ${theme.accentColor}10` : '1px solid transparent'))),
    transform: (isDragging ? 'rotate(5deg)' : ((isHovered || isActive) ? 'translateX(1px)' : 'translateX(0)')),
    boxShadow: (isDragging ? '0 4px 12px rgba(0,0,0,0.2)' : ((isHovered || isActive) ? `0 1px 4px ${theme.accentColor}10` : 'none')),
    opacity: isDragging ? 0.5 : 1,
    paddingRight: (isHovered || isActive) ? '4px' : '8px'
  }), [isDragging, isDragOver, isHovered, isActive, level, theme, isConnected]);

  // ÊãñÊãΩ‰∫ã‰ª∂Ôºö‰∏çÂèò
  const handleDragStart = (e) => {
    if (isDraggable) {
      setDragSourceId(node.id);
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', node.id);
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'move';
    if (isDropTarget && dragSourceId && dragSourceId !== node.id) {
      setDragOverNodeId(node.id);
    }
  };

  const handleDragLeave = (e) => {
    e.stopPropagation();
    if (isDropTarget && dragOverNodeId === node.id) {
      setDragOverNodeId(null);
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (isDropTarget && dragSourceId && dragSourceId !== node.id) {
      moveNode(dragSourceId, node.id);
    }
    setDragOverNodeId(null);
  };

  const handleClick = async (e) => {
    e.stopPropagation();
    if (isExpandable) {
      if (!hasChildren && !node.virtual) {  // ËôöÊãüËäÇÁÇπÂ∑≤Âä†ËΩΩ
        setIsLoading(true);
        try {
          const updatedNode = await loadNodeChildren(node);
          if (updatedNode && updatedNode.children) {
            updateTreePath(node.id, (current) => ({
              ...current,
              children: updatedNode.children,
              expanded: true
            }));
          }
          setExpandedKeys((prev) => new Map(prev).set(node.id, true));
        } catch (error) {
          console.error('Âä†ËΩΩÂ§±Ë¥•:', error);
        } finally {
          setIsLoading(false);
        }
      } else {
        setExpandedKeys((prev) => new Map(prev).set(node.id, !prev.get(node.id)));
      }
    }
  };

  const handlePrimaryAction = (e) => {
    e.stopPropagation();
    if (primaryAction && !activeMoreMenuNode) {
      // ‰ΩøÁî® dynamicHandler Ë∞ÉÁî®
      actionHandlers.dynamicHandler(primaryAction.handler || 'defaultAction', node);
      // ÂØπ‰∫é connectionÔºåËøûÊé•ÂêéÂä†ËΩΩ children
      if (node.type === 'connection') {
        connectDatabase(node).then((ok) => {
          if (ok) loadNodeChildren(node).then((updated) => updateTreePath(node.id, () => updated));
        });
      }
    }
  };

  const handleMoreMenu = (e) => {
    e.stopPropagation();
    if (!activeMoreMenuNode) {
      setActiveMoreMenuNode(node.id);
      onMoreMenu(e, node);
    }
  };

  const handleContextMenu = (e) => {
    e.preventDefault();
    e.stopPropagation();
    handleMoreMenu(e);
  };

  return (
    <div
      className={`tree-node ${node.type} ${isExpanded ? 'expanded' : ''} ${isHovered || isActive ? 'hovered' : ''} ${isDragging ? 'dragging' : ''} ${isDragOver ? 'drag-over' : ''}`}
      style={combinedStyles}
      draggable={isDraggable}
      onMouseEnter={() => !isDragging && setHoveredNode(node.id)}
      onMouseLeave={() => !isDragging && setHoveredNode(null)}
      onClick={handleClick}
      onContextMenu={handleContextMenu}
      onKeyDown={(e) => { if (e.key === 'Enter') handleClick(e); }}
      tabIndex={0}
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {(isHovered || isActive || isDragOver) && <div style={indicatorBarStyles(theme)} />}

      <div style={expandIconStyles(isHovered || isActive || isDragOver, theme)}>
        {isLoading ? (
          <span style={{ fontSize: 9 }}>‚ü≥</span>
        ) : getExpandIcon(node) ? (
          <span style={{ fontSize: 9, fontWeight: 'bold' }}>
            {getExpandIcon(node)}
          </span>
        ) : (
          <div style={{ width: 10, height: 10 }} />
        )}
      </div>

      <img
        src={getNodeIcon(node)}
        alt={node.type + (isConnected ? ' (connected)' : '')}
        style={nodeIconStyles(isHovered || isActive || isDragOver, theme)}
      />

      <span style={{ ...nodeNameStyles(isHovered || isActive || isDragOver), color: (isHovered || isActive || isDragOver) ? theme.textColor : '#333' }}>
        {node.name}
      </span>

      {(isHovered || isActive || isDragOver) && (
        <span style={typeLabelStyles(isHovered || isActive || isDragOver, theme)}>
          {node.type} {isConnected && '(Â∑≤ËøûÊé•)'} {node.virtual && '(ËôöÊãü)'}
        </span>
      )}

      {(isHovered || isActive) && !isLoading && !isDragging && (
        <div style={actionContainerStyles}>
          {primaryAction && (
            <button
              onClick={handlePrimaryAction}
              style={actionButtonStyles(theme)}
              disabled={!!activeMoreMenuNode}
              onMouseEnter={(e) => {
                if (!activeMoreMenuNode) {
                  e.target.style.background = 'white';
                  e.target.style.transform = 'scale(1.05)';
                  e.target.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.15)';
                }
              }}
              onMouseLeave={(e) => {
                if (!activeMoreMenuNode) {
                  e.target.style.background = 'rgba(255, 255, 255, 0.8)';
                  e.target.style.transform = 'scale(1)';
                  e.target.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                }
              }}
            >
              {primaryAction.icon}
            </button>
          )}

          <button
            onClick={handleMoreMenu}
            style={{
              ...actionButtonStyles(theme),
              color: '#666',
              fontSize: '14px'
            }}
            disabled={!!activeMoreMenuNode && activeMoreMenuNode !== node.id}
            onMouseEnter={(e) => {
              if (!activeMoreMenuNode || activeMoreMenuNode === node.id) {
                e.target.style.background = 'white';
                e.target.style.transform = 'scale(1.05)';
                e.target.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.15)';
                e.target.style.color = theme.accentColor;
              }
            }}
            onMouseLeave={(e) => {
              if (!activeMoreMenuNode || activeMoreMenuNode === node.id) {
                e.target.style.background = 'rgba(255, 255, 255, 0.8)';
                e.target.style.transform = 'scale(1)';
                e.target.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.1)';
                e.target.style.color = '#666';
              }
            }}
          >
            ‚ãØ
          </button>
        </div>
      )}

      {(isHovered || isActive || isDragOver) && hasChildren && !primaryAction && !isLoading && (
        <div style={childIndicatorStyles(theme)} />
      )}
    </div>
  );
});

TreeNode.displayName = 'TreeNode';

export default TreeNode;

// =========================================

src/components/toptoolbar/ToolbarTop.jsx

import React from 'react';
import '../../css/ToolbarTop.css';
import NewFileIcon from '../../public/icons/toptoolbar/new_folder_2_color.svg';
import ConnectIcon from '../../public/icons/toptoolbar/new_connection_3_color.svg';
import QueryIcon from '../../public/icons/toptoolbar/query_3.svg';
import SearchIcon from '../../public/icons/toptoolbar/new_folder_1.svg'; // ÂÅáËÆæÂõæÊ†á
import ExecuteIcon from '../../public/icons/toptoolbar/new_folder_1.svg'; // ÂÅáËÆæÂõæÊ†á
import RefreshIcon from '../../public/icons/toptoolbar/refresh.svg'; // ÂÅáËÆæÂà∑Êñ∞ÂõæÊ†á
import { useTabsStore } from '../../stores/useTabsStore';
import { useTreeStore } from '../../stores/useTreeStore';
import { openNewGroup, openNewConnection } from '../modals/modalActions'; // ÂØºÂÖ• actions
import { useModal } from '../modals/ModalProvider'; // ‰øÆÂ§çÔºöÂØºÂÖ• useModal Hook

const ToolbarTop = () => {
  const addTab = useTabsStore((state) => state.addTab);
  const refreshTree = useTreeStore((state) => state.refreshTree);
  const { openModal } = useModal(); // ‰øÆÂ§çÔºöËé∑Âèñ openModal

  return (
    <div className="toolbar-top">
      <div className="toolbar-top-left">
        <button
          className="btn btn-icon"
          title="Êñ∞Âª∫ÂàÜÁªÑ"
          onClick={() => openNewGroup(null, openModal)} // ‰øÆÂ§çÔºö‰º†ÈÄí openModal ÂèÇÊï∞
        >
          <img src={NewFileIcon} alt="Êñ∞Âª∫ÂàÜÁªÑ" className="icon" />
        </button>
        <button
          className="btn btn-icon"
          title="Êñ∞Âª∫ËøûÊé•"
          onClick={() => openNewConnection(null, openModal)} // ‰øÆÂ§çÔºö‰º†ÈÄí openModal ÂèÇÊï∞
        >
          <img src={ConnectIcon} alt="Êñ∞Âª∫ËøûÊé•" className="icon" />
        </button>
        <button className="btn btn-icon" title="Êñ∞Âª∫Êü•ËØ¢" onClick={addTab}>
          <img src={QueryIcon} alt="Êñ∞Âª∫Êü•ËØ¢" className="icon" />
        </button>
        <select className="toolbar-dropdown" title="Êìç‰ΩúËèúÂçï">
          <option>Êìç‰Ωú</option>
          <option>ËøûÊé•</option>
          <option>ÂØºÂá∫</option>
        </select>
      </div>
      <div className="toolbar-top-right">
        <button className="btn btn-icon" title="ÊêúÁ¥¢">
          <img src={SearchIcon} alt="ÊêúÁ¥¢" className="icon" />
        </button>
        <button className="btn btn-icon" title="ÊâßË°å">
          <img src={ExecuteIcon} alt="ÊâßË°å" className="icon" />
        </button>
        <button className="btn btn-icon" title="Âà∑Êñ∞Ê†ë" onClick={refreshTree}>
          <img src={RefreshIcon} alt="Âà∑Êñ∞" className="icon" />
        </button>
      </div>
    </div>
  );
};

export default ToolbarTop;

// =========================================

src/css/appLoading.css

:root {
  --loading-bg: #f8f9fa;
  --loading-primary: #0b69ff;
  --loading-secondary: #e9ecef;
  --loading-text: #6c757d;
  --loading-glow: rgba(11, 105, 255, 0.1);
  --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10000;
  font-family: var(--font);
  overflow: hidden;
  /* Á°Æ‰øùË¶ÜÁõñElectronÊ†áÈ¢òÊ†è */
  -webkit-app-region: no-drag;
}

/* ElectronÁ™óÂè£Ê†áÈ¢òÊ†èÈÄÇÈÖç */
.loading-overlay::after {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 32px; /* ElectronÊ†áÈ¢òÊ†èÈ´òÂ∫¶ */
  background: linear-gradient(135deg, rgba(248, 249, 250, 0.95) 0%, rgba(233, 236, 239, 0.95) 100%);
  z-index: 10001;
  pointer-events: none;
}

.loading-overlay::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: 
    radial-gradient(circle at 20% 80%, rgba(11, 105, 255, 0.05) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(11, 105, 255, 0.05) 0%, transparent 50%),
    linear-gradient(45deg, transparent 30%, rgba(11, 105, 255, 0.02) 50%, transparent 70%);
  animation: shimmer 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes shimmer {
  0%, 100% { opacity: 0.3; transform: translateX(-100%) translateY(-100%); }
  50% { opacity: 0.6; transform: translateX(100%) translateY(100%); }
}

.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 32px;
  max-width: 400px;
  padding: 0 24px;
  text-align: center;
  position: relative;
  z-index: 10002;
  /* ÁªôÊ†áÈ¢òÊ†èÁïôÂá∫Á©∫Èó¥ */
  margin-top: 32px;
}

.loading-logo {
  width: 64px;
  height: 64px;
  background: linear-gradient(135deg, var(--loading-primary) 0%, #4299e1 100%);
  border-radius: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  box-shadow: 0 8px 32px rgba(11, 105, 255, 0.15);
  animation: pulse 2s ease-in-out infinite;
}

.loading-logo::before {
  content: '‚ö°';
  font-size: 28px;
  color: white;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 8px 32px rgba(11, 105, 255, 0.15);
  }
  50% {
    transform: scale(1.05);
    box-shadow: 0 12px 48px rgba(11, 105, 255, 0.25);
  }
}

.loading-title {
  font-size: 24px;
  font-weight: 700;
  background: linear-gradient(135deg, var(--loading-primary) 0%, #4299e1 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin: 0;
  letter-spacing: -0.025em;
  animation: slideInDown 1s ease-out 0.5s both;
}

@keyframes slideInDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.loading-subtitle {
  font-size: 14px;
  color: var(--loading-text);
  margin: 0;
  opacity: 0.8;
  animation: slideInUp 1s ease-out 0.7s both;
}

@keyframes slideInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.loading-progress {
  width: 100%;
  height: 4px;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 2px;
  overflow: hidden;
  position: relative;
  animation: slideInUp 1s ease-out 0.9s both;
}

.loading-progress::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--loading-primary) 0%, #4299e1 50%, var(--loading-primary) 100%);
  border-radius: 2px;
  animation: progress 2s ease-in-out infinite;
  box-shadow: 0 0 10px var(--loading-glow);
}

@keyframes progress {
  0% { width: 0%; }
  50% { width: 70%; }
  100% { width: 100%; }
}

.loading-dots {
  display: flex;
  gap: 4px;
  align-items: center;
  animation: slideInUp 1s ease-out 1.1s both;
}

.loading-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--loading-primary);
  opacity: 0.3;
  animation: dotPulse 1.4s ease-in-out infinite both;
}

.loading-dot:nth-child(1) { animation-delay: 0s; }
.loading-dot:nth-child(2) { animation-delay: 0.2s; }
.loading-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes dotPulse {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.3;
  }
  40% {
    transform: scale(1.2);
    opacity: 0.8;
  }
}

/* Âä†ËΩΩÂÆåÊàêÊó∂ÁöÑÊ∑°Âá∫Âä®Áîª */
.loading-overlay.fade-out {
  animation: fadeOut 0.5s ease-out forwards;
}

@keyframes fadeOut {
  to {
    opacity: 0;
    visibility: hidden;
  }
}

/* ÂìçÂ∫îÂºèËÆæËÆ° */
@media (max-width: 480px) {
  .loading-content {
    gap: 24px;
    padding: 0 16px;
    margin-top: 24px;
  }
  
  .loading-logo {
    width: 48px;
    height: 48px;
  }
  
  .loading-logo::before {
    font-size: 20px;
  }
  
  .loading-title {
    font-size: 20px;
  }
  
  .loading-subtitle {
    font-size: 13px;
  }
}

/* Ê∑±Ëâ≤Ê®°ÂºèÊîØÊåÅ */
@media (prefers-color-scheme: dark) {
  .loading-overlay {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
  }
  
  .loading-overlay::after {
    background: linear-gradient(135deg, rgba(26, 26, 26, 0.95) 0%, rgba(45, 45, 45, 0.95) 100%);
  }
  
  .loading-progress {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .loading-subtitle {
    color: rgba(255, 255, 255, 0.7);
  }
}

// =========================================

src/css/index.css

/** css/index.css */
:root {
  --sidebar-bg: #fafafa;
  --border: #e6e6e6;
  --toolbar-bg: #f5f5f7;
  --accent: #0b69ff;
  --muted: #999;
  --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.08);

  /* Â∞∫ÂØ∏ÂèòÈáè - ÈÄöËøá JS Âä®ÊÄÅËÆæÁΩÆ */
  --sidebar-width: 260px;
  --editor-height: 300px; /* Â¢ûÂä†ÈªòËÆ§È´òÂ∫¶ */

  /* Áªü‰∏ÄÁöÑÊãñÊãΩÂô®Ê†∑Âºè */
  --resizer-default-bg: #f8f9fa;
  --resizer-border: #e9ecef;
  --resizer-hover-bg: #e9ecef;
  --resizer-dragging-bg: rgba(11, 105, 255, 0.1);
  --resizer-indicator-size: 20px;
  --resizer-indicator-color: var(--muted);
}

* {
  box-sizing: border-box;
}

body,
html,
#root {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: var(--font);
  font-size: 13px;
  color: #222;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Èò≤Ê≠¢Âè≥ÈîÆËèúÂçïÂíåÁ≥ªÁªüUIÂá∏Âá∫ */
body,
html {
  position: relative;
  z-index: 1;
}

/* ‰∏ªÂÆπÂô® - ‰ΩøÁî® CSS Grid Â∏ÉÂ±Ä */
.app-container {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  grid-template-rows: 50px 1fr; /* ÂÖ®Â±ÄÈ°∂ÈÉ®Â∑•ÂÖ∑Ê†èÈ´òÂ∫¶ */
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  position: relative;
  z-index: 2;
  background: white;
}

/* Sidebar */
.sidebar {
  grid-column: 1;
  grid-row: 2;
  background: var(--sidebar-bg);
  padding: 12px;
  position: relative;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  z-index: 5;
  overflow: hidden;
  transition: width 0.2s ease;
  min-width: 180px;
  max-width: 500px;
}

.sidebar h3 {
  margin: 0 0 10px 0;
  font-size: 16px;
  font-weight: 600;
  color: #333;
}

.sidebar ul {
  list-style: none;
  padding-left: 0;
  margin: 0;
  color: #222;
}

.sidebar li {
  padding: 6px 0;
  cursor: default;
}

.sidebar .folder {
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.sidebar .sub {
  margin-left: 12px;
  color: var(--muted);
}

/* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏° */
.sidebar.dragging-parent,
.sidebar.dragging-parent * {
  transition: none !important;
}

/* Áªü‰∏ÄÁöÑÊãñÊãΩÂô®Ê†∑Âºè - ÂûÇÁõ¥ÂàÜÈöîÂô®Ôºà‰æßËæπÊ†èÔºâ*/
.resizer.sidebar-resizer {
  position: absolute;
  right: 0;
  top: 0;
  width: 6px;
  height: 100%;
  background: var(--resizer-default-bg);
  border-top: 1px solid var(--resizer-border);
  border-bottom: 1px solid var(--resizer-border);
  z-index: 5;
  transition: all 0.2s ease;
  cursor: ew-resize;
  flex-shrink: 0;
}

.resizer.sidebar-resizer::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 3px;
  height: var(--resizer-indicator-size);
  background: var(--resizer-indicator-color);
  border-radius: 2px;
  opacity: 0.3;
}

.resizer.sidebar-resizer:hover {
  background: var(--resizer-hover-bg);
}

.resizer.sidebar-resizer.dragging {
  background: var(--resizer-dragging-bg);
}

.resizer.sidebar-resizer.dragging::before {
  opacity: 0.5;
  background: var(--accent);
}

/* Main Panel */
.main-panel {
  grid-column: 2;
  grid-row: 2;
  display: grid;
  grid-template-rows: 40px 42px 1fr;
  background: white;
  position: relative;
  z-index: 1;
  overflow: hidden;
}

/* Top Toolbar */
.toolbar-top {
  grid-column: 1 / -1; /* Ë∑®Ë∂äÊï¥‰∏™ÂÆΩÂ∫¶ */
  grid-row: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 16px;
  background: var(--toolbar-bg);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  position: relative;
  z-index: 6;
}

.toolbar-top-left,
.toolbar-top-right {
  display: flex;
  align-items: center;
  gap: 8px;
}

.btn-icon {
  padding: 6px;
  border-radius: 4px;
  background: white;
  border: 1px solid #e9e9e9;
  cursor: pointer;
  font-size: 16px;
  color: #333;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
}

.btn-icon:hover {
  background: #f8f9fa;
  border-color: #ccc;
  box-shadow: var(--shadow-sm);
}

.toolbar-dropdown {
  padding: 6px 12px;
  border-radius: 4px;
  border: 1px solid #e9e9e9;
  background: white;
  cursor: pointer;
  font-size: 13px;
  color: #333;
  transition: all 0.2s ease;
}

.toolbar-dropdown:hover {
  background: #f8f9fa;
  border-color: #ccc;
}

/* Toolbar */
.toolbar {
  grid-row: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 16px;
  background: var(--toolbar-bg);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  position: relative;
  z-index: 6;
}

.toolbar-left,
.toolbar-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.toolbar .btn {
  padding: 4px 8px; /* Reduced padding */
  border-radius: 6px; /* Slightly smaller radius */
  background: white;
  border: none;
  cursor: pointer;
  font-weight: 600;
  font-size: 12px; /* Smaller font size */
  color: #333;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 4px; /* Reduced gap */
  text-decoration: none;
  outline: none;
  position: relative;
  z-index: 7;
  box-shadow: none;
  width: 25px; /* Reduced width */
  height: 25px; /* Reduced height */
}

.toolbar .btn:hover {
  background: #f8f9fa;
  border-color: #ccc;
  box-shadow: var(--shadow-sm);
}

.toolbar .btn:active {
  transform: translateY(1px);
}

.toolbar .btn-execute {
  color: var(--accent);
  border-color: var(--accent);
  background: rgba(11, 105, 255, 0.05);
}

.toolbar .btn-execute:hover {
  background: rgba(11, 105, 255, 0.1);
}

/* Tabs Container */
.tabs-container {
  grid-row: 2;
  display: flex;
  align-items: center;
  background: white;
  border-bottom: 1px solid var(--border);
  overflow: hidden;
  position: relative;
  z-index: 6;
}

.tabs-header {
  flex: 1;
  display: flex;
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-width: none;
  -ms-overflow-style: none;
  scroll-behavior: smooth;
  background: white;
  position: relative;
  z-index: 7;
}

.tabs-header::-webkit-scrollbar {
  display: none;
}

/* TabÊªöÂä®ÊåâÈíÆ */
.tab-scroll-btn {
  background: rgba(11, 105, 255, 0.8);
  border: none;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  color: white;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 4px;
  transition: all 0.2s ease;
  flex-shrink: 0;
  position: relative;
  z-index: 8;
}

.tab-scroll-btn:hover {
  background: var(--accent);
  box-shadow: var(--shadow-sm);
  transform: scale(1.05);
}

.tab-scroll-btn:active {
  transform: scale(0.95);
}

.tab-scroll-left {
  margin-left: 8px;
}

.tab-scroll-right {
  margin-right: 8px;
}

.tab-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  min-width: 120px;
  max-width: 180px;
  background: white;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  transition: all 0.2s ease;
  min-height: 42px;
  position: relative;
  z-index: 8;
  flex-shrink: 0;
  font-size: 13px;
}

.tab-item:hover {
  background: #f8f9fa;
}


.tab-item.active {
  background: #f5f7fa;            /* ÊüîÂíåÁöÑÊµÖËâ≤ËÉåÊôØ */
  color: #0078d7;                 /* ‰∏ªËâ≤Ë∞ÉÊñáÂ≠ó */
  font-weight: 500;               /* Â≠ó‰ΩìÁ®çÂä†Á≤ó */
  border-bottom: 2px solid #0078d7; /* Áî®Â∫ïËæπÁ∫øÊù•Á™ÅÂá∫ */
}

.tab-title {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: 500;
  font-size: 13px;
  text-align: center;
}

.tab-close {
  background: none;
  border: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  color: var(--muted);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: all 0.2s ease;
  position: relative;
  z-index: 9;
  flex-shrink: 0;
}

.tab-item:hover .tab-close,
.tab-item.active .tab-close {
  opacity: 1;
}

.tab-close:hover {
  background: #f0f0f0;
  color: #666;
}

.tab-close:active {
  transform: scale(0.9);
}

/* TabËÆ°Êï∞Âô® */
.tab-counter {
  background: rgba(11, 105, 255, 0.1);
  color: var(--muted);
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 12px;
  margin: 0 8px;
  flex-shrink: 0;
  white-space: nowrap;
  border: 1px solid rgba(11, 105, 255, 0.2);
  font-weight: 500;
}

/* Èº†Ê†áÊªöËΩÆÊªöÂä®tab */
.tabs-header {
  scroll-snap-type: x mandatory;
}

.tab-item {
  scroll-snap-align: start;
}

/* Editor and Result Area */
.editor-and-result {
  grid-row: 3;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
  background: white;
  position: relative;
  z-index: 4;
}

/* Editor Area */
.editor-area {
  height: var(--editor-height, 300px);
  min-height: 150px; /* Â¢ûÂä†ÊúÄÂ∞èÈ´òÂ∫¶ */
  max-height: 80vh; /* Â¢ûÂä†ÊúÄÂ§ßÈ´òÂ∫¶ */
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  position: relative;
  z-index: 5;
  background: white;
  transition: height 0.2s ease;
  flex-shrink: 0;
  overflow: hidden;
}

/* SQL Editor */
.sql-editor {
  flex: 1;
  padding: 2px;
  display: flex;
  flex-direction: column;
  position: relative;
  z-index: 3;
  min-height: 0;
  overflow: hidden;
}

/* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏° */
.editor-area.dragging,
.editor-area.dragging * {
  transition: none !important;
}

/* Áªü‰∏ÄÁöÑÊãñÊãΩÂô®Ê†∑Âºè - Ê∞¥Âπ≥ÂàÜÈöîÂô®ÔºàÁºñËæëÂô®Ôºâ*/
.resizer.editor-divider {
  height: 6px;
  background: var(--resizer-default-bg);
  border-top: 1px solid var(--resizer-border);
  border-bottom: 1px solid var(--resizer-border);
  cursor: row-resize;
  flex-shrink: 0;
  position: relative;
  z-index: 6;
  transition: all 0.2s ease;
  width: 100%;
}

.resizer.editor-divider::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: var(--resizer-indicator-size);
  height: 3px;
  background: var(--resizer-indicator-color);
  border-radius: 2px;
  opacity: 0.3;
}

.resizer.editor-divider:hover {
  background: var(--resizer-hover-bg);
}

.resizer.editor-divider.dragging {
  background: var(--resizer-dragging-bg);
}

.resizer.editor-divider.dragging::before {
  opacity: 0.5;
  background: var(--accent);
}

/* Result Area */
.result-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  overflow: hidden;
  position: relative;
  z-index: 4;
}

.result-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  background: #fafbfc;
  flex-shrink: 0;
  min-height: 40px;
  position: relative;
  z-index: 5;
}

.left-controls,
.right-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.icon-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border: 1px solid #e1e5e9;
  background: white;
  border-radius: 6px;
  cursor: pointer;
  color: var(--muted);
  font-size: 14px;
  transition: all 0.2s ease;
  outline: none;
  position: relative;
  z-index: 6;
  box-shadow: none;
}

.icon-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: rgba(11, 105, 255, 0.05);
}

.icon-btn:active {
  transform: scale(0.95);
}

.limit-text,
.row-count {
  color: var(--muted);
  font-size: 12px;
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.05);
  font-weight: 500;
}

.result-content {
  flex: 1;
  overflow: auto;
  position: relative;
  z-index: 4;
  background: white;
}

/* Result Table */
.result-table {
  width: 100%;
  height: 100%;
  position: relative;
  z-index: 5;
}

.result-table table {
  border-collapse: collapse;
  width: 100%;
  min-width: 400px;
  position: relative;
  z-index: 6;
}

.result-table th,
.result-table td {
  border: 1px solid #f0f0f0;
  padding: 10px 12px;
  text-align: left;
  font-size: 13px;
  vertical-align: top;
  word-break: break-word;
  position: relative;
  z-index: 7;
}

.result-table th {
  background: #fafbfc;
  font-weight: 600;
  color: #333;
  position: sticky;
  top: 0;
  z-index: 8;
  box-shadow: none;
}

.result-table tr:nth-child(even) {
  background: #fdfdfd;
}

.result-table tr:hover {
  background: #f8f9fa;
}

/* Empty State */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--muted);
  text-align: center;
  padding: 40px 20px;
  position: relative;
  z-index: 5;
}

.empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.3;
}

.empty-state p {
  margin: 0;
  font-size: 14px;
}

/* ÊªöÂä®Êù°Ê†∑Âºè */
*::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

*::-webkit-scrollbar-track {
  background: transparent;
}

*::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
}

*::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.2);
}

/* ÂìçÂ∫îÂºè */
@media (max-width: 768px) {
  :root {
    --resizer-indicator-size: 16px;
  }

  .app-container {
    grid-template-columns: 200px 1fr;
  }

  .sidebar {
    min-width: 150px;
  }

  .toolbar-top {
    padding: 0 12px;
    gap: 8px;
  }

  .toolbar-top .btn-icon {
    width: 28px;
    height: 28px;
    font-size: 14px;
  }

  .toolbar {
    padding: 0 12px;
    gap: 8px;
  }

  .toolbar .btn {
    padding: 4px 8px;
    font-size: 12px;
  }

  .result-header {
    padding: 8px 12px;
  }

  .resizer.sidebar-resizer {
    width: 4px;
  }

  .resizer.sidebar-resizer::before {
    height: 16px;
  }

  .resizer.editor-divider::before {
    width: 16px;
  }

  .tab-item {
    min-width: 100px;
    max-width: 140px;
    padding: 8px 12px;
    font-size: 12px;
  }

  .tab-title {
    font-size: 12px;
  }

  .tab-scroll-btn {
    width: 24px;
    height: 24px;
    font-size: 12px;
    margin: 0 2px;
  }

  .tab-counter {
    font-size: 11px;
    padding: 2px 6px;
    margin: 0 4px;
  }

  .tabs-header {
    height: 38px;
  }

  .tabs-container {
    height: 38px;
  }
}

/* ‰øÆÂ§çmacOSÁ™óÂè£Ê†áÈ¢òÊ†èÈóÆÈ¢ò */
@media (-webkit-app-region: no-drag) {
  .app-container {
    padding-top: 0 !important;
    margin-top: 0 !important;
  }
}

/* Èò≤Ê≠¢ElectronÊàñÂÖ∂‰ªñÊ°ÜÊû∂ÁöÑËèúÂçïÊ†èÂΩ±Âìç */
body > :first-child {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* ÊãñÊãΩÊó∂ÁöÑÂÖ®Â±ÄÊ†∑Âºè */
body.dragging * {
  user-select: none !important;
  -webkit-user-select: none !important;
  -moz-user-select: none !important;
  -ms-user-select: none !important;
}

body.dragging {
  cursor: ew-resize !important;
}

/* ÊãñÊãΩËøáÁ®ã‰∏≠Á¶ÅÁî®ÊâÄÊúâÂä®Áîª */
body.dragging * {
  transition: none !important;
  transform: none !important;
}

@keyframes modalSlideIn {
  from {
    opacity: 0;
    transform: translateY(-20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

// =========================================

src/css/NewConnectionModal.css

/* src/css/NewConnectionModal.css */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  border-radius: 8px;
  padding: 20px;
  width: 400px;
  max-width: 90%;
  box-shadow: var(--shadow-md);
  position: relative;
}

.modal-title {
  margin: 0 0 16px;
  font-size: 16px;
  font-weight: 600;
  color: #333;
}

.form-section {
  margin-bottom: 8px;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 2px;
}

.checkbox-group {
  flex-direction: row;
  align-items: center;
  gap: 8px;
}

.form-group label {
  font-size: 13px;
  font-weight: 500;
  color: #333;
}

.modal-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  color: #1a1a1a;
  background: #fdfdfd;
  outline: none;
  transition: border-color 0.2s ease;
}

.modal-input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(11, 105, 255, 0.1);
}

.password-wrapper {
  position: relative;
}

.toggle-password {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: var(--accent);
  cursor: pointer;
  font-size: 12px;
  padding: 2px 6px;
}

.status-message {
  margin: 8px 0;
  padding: 8px;
  border-radius: 4px;
  font-size: 12px;
}

.status-message.success {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.status-message.error {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.btn {
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid var(--border);
}

.btn-secondary {
  background: white;
  color: var(--accent);
  border-color: var(--accent);
}

.btn-secondary:hover {
  background: rgba(11, 105, 255, 0.1);
}

.btn-cancel {
  background: white;
  color: #333;
}

.btn-cancel:hover {
  background: #f8f9fa;
  border-color: #ccc;
}

.btn-primary {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.btn-primary:hover {
  background: rgba(11, 105, 255, 0.9);
}

.btn-primary:disabled {
  background: #ccc;
  border-color: #ccc;
  cursor: not-allowed;
}

// =========================================

src/css/NewGroupModal.css

/* src/css/NewGroupModal.css */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  border-radius: 8px;
  padding: 20px;
  width: 400px;
  max-width: 90%;
  box-shadow: var(--shadow-md);
  position: relative;
}

.modal-title {
  margin: 0 0 16px;
  font-size: 16px;
  font-weight: 600;
  color: #333;
}

.form-group {
  margin-bottom: 16px;
}

.form-group label {
  display: block;
  font-size: 13px;
  font-weight: 500;
  color: #333;
  margin-bottom: 8px;
}

.modal-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  color: #1a1a1a;
  background: #fdfdfd;
  outline: none;
  transition: border-color 0.2s ease;
}

.modal-input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(11, 105, 255, 0.1);
}

.modal-input::placeholder {
  color: var(--muted);
  font-style: italic;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.btn {
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid var(--border);
}

.btn-cancel {
  background: white;
  color: #333;
}

.btn-cancel:hover {
  background: #f8f9fa;
  border-color: #ccc;
}

.btn-primary {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.btn-primary:hover {
  background: rgba(11, 105, 255, 0.9);
}

.btn-primary:disabled {
  background: #ccc;
  border-color: #ccc;
  cursor: not-allowed;
}

// =========================================

src/css/SqlEditor.css

/** SqlEditor.css **/
.sql-editor {
  flex: 1;
  padding: 12px;
  display: flex;
  flex-direction: column;
  position: relative;
  z-index: 6;
  min-height: 0;
  overflow: hidden;
  box-sizing: border-box;
}

.codemirror-custom {
  width: 100%;
  height: 100%;
  min-height: 80px;
  border: 1px solid #e1e5e9;
  border-radius: 6px;
  font-family: 'Fira Code', 'SF Mono', Monaco, Consolas, monospace; /* ‰ºòÂåñÂ≠ó‰ΩìÊ†à */
  font-size: 14px; /* Â¢ûÂä†Â≠ó‰ΩìÂ§ßÂ∞èÔºåÊèêÂçáÂèØËØªÊÄß */
  line-height: 1.6; /* Ë∞ÉÊï¥Ë°åÈ´òÔºåÂ¢ûÂä†Èó¥Ë∑ù */
  color: #1a1a1a;
  background: #fdfdfd;
  outline: none;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  box-shadow: none;
}

.codemirror-custom .cm-scroller {
  overflow-y: auto;
  overflow-x: auto;
  box-sizing: border-box;
}

.codemirror-custom .cm-content {
  padding: 12px;
}

/* ËÅöÁÑ¶Êó∂ÁöÑÊ†∑Âºè */
.codemirror-custom.cm-focused {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(11, 105, 255, 0.1);
}

/* Âç†‰ΩçÁ¨¶Ê†∑Âºè */
.codemirror-custom .cm-placeholder {
  color: var(--muted);
  font-style: italic;
}

/* ÊãñÊãΩÊó∂Á¶ÅÁî®ÊåáÈíà‰∫ã‰ª∂ */
.editor-area.dragging .codemirror-custom {
  pointer-events: none;
}

/* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏° */
.editor-area.dragging,
.editor-area.dragging * {
  transition: none !important;
}

// =========================================

src/css/ToolbarTop.css

/* ToolbarTop.css */
.toolbar-top {
  grid-column: 1 / -1;
  grid-row: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 16px;
  background: var(--toolbar-bg);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  position: relative;
  z-index: 6;
}

.toolbar-top-left,
.toolbar-top-right {
  display: flex;
  align-items: center;
  gap: 8px;
}

.btn-icon {
  padding: 6px;
  border-radius: 4px;
  background: white;
  border: 1px solid #e9e9e9;
  cursor: pointer;
  font-size: 16px;
  color: #333;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
}

.btn-icon:hover {
  background: #f8f9fa;
  border-color: #ccc;
  box-shadow: var(--shadow-sm);
}

/* Add styles for the icon images */
.btn-icon .icon {
  width: 20px; /* Adjust size as needed */
  height: 20px;
  object-fit: contain; /* Ensure icons scale properly */
}

.toolbar-dropdown {
  padding: 6px 12px;
  border-radius: 4px;
  border: 1px solid #e9e9e9;
  background: white;
  cursor: pointer;
  font-size: 13px;
  color: #333;
  transition: all 0.2s ease;
}

.toolbar-dropdown:hover {
  background: #f8f9fa;
  border-color: #ccc;
}

/* Responsive */
@media (max-width: 768px) {
  .toolbar-top {
    padding: 0 12px;
    gap: 8px;
  }

  .toolbar-top .btn-icon {
    width: 28px;
    height: 28px;
    font-size: 14px;
  }

  .toolbar-top .btn-icon .icon {
    width: 18px; /* Adjust size for smaller screens */
    height: 18px;
  }
}

// =========================================

src/hooks/useResize.js

import { useState, useRef, useEffect, useCallback } from 'react';

export const useResize = (initialSidebarWidth = 260, initialEditorHeight = 300, sidebarRef) => { // ‰øÆÂ§çÔºöÊé•Êî∂ sidebarRef ÂèÇÊï∞
  const [sidebarWidth, setSidebarWidth] = useState(initialSidebarWidth);
  const [editorHeight, setEditorHeight] = useState(initialEditorHeight);
  const isResizingSidebar = useRef(false);
  const isResizingEditor = useRef({ active: false }); // ‰øÆÂ§çÔºöÁî®ÂØπË±°ÁÆ°ÁêÜÁä∂ÊÄÅÔºåÈÅøÂÖçÂ∏ÉÂ∞îÊ∑∑Ê∑Ü

  const handleSidebarMouseDown = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    isResizingSidebar.current = true;
    document.body.style.cursor = 'ew-resize';
    document.body.style.userSelect = 'none';
    document.body.classList.add('dragging');
  }, []);

  const handleEditorMouseDown = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    const initialMouseY = e.clientY;
    const initialEditorHeightState = editorHeight;
    isResizingEditor.current = { active: true, initialMouseY, initialEditorHeight: initialEditorHeightState };
    document.body.style.cursor = 'row-resize';
    document.body.style.userSelect = 'none';
    document.body.classList.add('dragging');
  }, [editorHeight]);

  const handleMouseMoveOptimized = useCallback((e) => {
    if (isResizingSidebar.current && sidebarRef?.current) { // ‰øÆÂ§çÔºöÂÆâÂÖ®Ê£ÄÊü• sidebarRef
      const newWidth = Math.min(Math.max(e.clientX, 180), 500);
      sidebarRef.current.style.width = `${newWidth}px`;
      document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
      setSidebarWidth(newWidth);
    }

    if (isResizingEditor.current.active) { // ‰øÆÂ§çÔºöÁî®ÂØπË±°.active Ê£ÄÊü•
      const resizeState = isResizingEditor.current;
      const currentMouseY = e.clientY;
      const newHeight = resizeState.initialEditorHeight + (currentMouseY - resizeState.initialMouseY);

      const minHeight = 150;
      const maxHeight = window.innerHeight * 0.8;
      const clampedHeight = Math.min(Math.max(newHeight, minHeight), maxHeight);

      if (document.documentElement) { // ÂÆâÂÖ®ËÆæÁΩÆ CSS ÂèòÈáè
        document.documentElement.style.setProperty('--editor-height', `${clampedHeight}px`);
      }
      setEditorHeight(clampedHeight);
    }
  }, [sidebarRef]); // ‰æùËµñÔºöÊ∑ªÂä† sidebarRef

  const handleMouseUp = useCallback(() => {
    if (isResizingSidebar.current || isResizingEditor.current.active) {
      isResizingSidebar.current = false;
      isResizingEditor.current = { active: false };
      document.body.style.cursor = 'default';
      document.body.style.userSelect = 'auto';
      document.body.classList.remove('dragging');
    }
  }, []);

  useEffect(() => {
    let rafId;
    const handleGlobalMouseMove = (e) => {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => handleMouseMoveOptimized(e));
    };
    const handleGlobalMouseUp = handleMouseUp;

    window.addEventListener('mousemove', handleGlobalMouseMove, { passive: true });
    window.addEventListener('mouseup', handleGlobalMouseUp);

    return () => {
      window.removeEventListener('mousemove', handleGlobalMouseMove);
      window.removeEventListener('mouseup', handleGlobalMouseUp);
      if (rafId) cancelAnimationFrame(rafId);
    };
  }, [handleMouseMoveOptimized, handleMouseUp]); // ‰øÆÂ§çÔºö‰æùËµñÊ≠£Á°Æ

  useEffect(() => {
    document.documentElement.style.setProperty('--sidebar-width', `${sidebarWidth}px`);
    document.documentElement.style.setProperty('--editor-height', `${editorHeight}px`);
  }, [sidebarWidth, editorHeight]);

  return {
    sidebarWidth,
    editorHeight,
    handleSidebarMouseDown,
    handleEditorMouseDown,
  };
};

// =========================================

src/main.jsx

import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.jsx'
import './css/index.css'

createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

// =========================================

src/stores/useResize.js

import { useState, useRef, useEffect, useCallback } from 'react';

export const useResize = (initialSidebarWidth = 260, initialEditorHeight = 300) => {
  const [sidebarWidth, setSidebarWidth] = useState(initialSidebarWidth);
  const [editorHeight, setEditorHeight] = useState(initialEditorHeight);
  const isResizingSidebar = useRef(false);
  const isResizingEditor = useRef(false);

  const handleSidebarMouseDown = useCallback((e, sidebarRef) => {
    e.preventDefault();
    e.stopPropagation();
    isResizingSidebar.current = true;
    document.body.style.cursor = 'ew-resize';
    document.body.style.userSelect = 'none';
    document.body.classList.add('dragging');
  }, []);

  const handleEditorMouseDown = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    isResizingEditor.current = true;
    document.body.style.cursor = 'row-resize';
    document.body.style.userSelect = 'none';
    document.body.classList.add('dragging');
  }, []);

  const handleMouseMoveOptimized = useCallback((e) => {
    if (isResizingSidebar.current && sidebarRef.current) { // ÂÅáËÆæ sidebarRef ‰ªéÁªÑ‰ª∂‰º†ÂÖ•
      const newWidth = Math.min(Math.max(e.clientX, 180), 500);
      sidebarRef.current.style.width = `${newWidth}px`;
      document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
      setSidebarWidth(newWidth);
    }

    if (isResizingEditor.current) {
      const newHeight = isResizingEditor.current.initialEditorHeight + (e.clientY - isResizingEditor.current.initialMouseY);
      const minHeight = 150;
      const maxHeight = window.innerHeight * 0.8;
      const clampedHeight = Math.min(Math.max(newHeight, minHeight), maxHeight);
      document.documentElement.style.setProperty('--editor-height', `${clampedHeight}px`);
      setEditorHeight(clampedHeight);
    }
  }, []);

  const handleMouseUp = useCallback(() => {
    if (isResizingSidebar.current || isResizingEditor.current) {
      isResizingSidebar.current = false;
      isResizingEditor.current = false;
      document.body.style.cursor = 'default';
      document.body.style.userSelect = 'auto';
      document.body.classList.remove('dragging');
    }
  }, []);

  useEffect(() => {
    let rafId;
    const handleGlobalMouseMove = (e) => {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => handleMouseMoveOptimized(e));
    };
    window.addEventListener('mousemove', handleGlobalMouseMove, { passive: true });
    window.addEventListener('mouseup', handleMouseUp);
    return () => {
      window.removeEventListener('mousemove', handleGlobalMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
      if (rafId) cancelAnimationFrame(rafId);
    };
  }, [handleMouseMoveOptimized, handleMouseUp]);

  useEffect(() => {
    document.documentElement.style.setProperty('--sidebar-width', `${sidebarWidth}px`);
    document.documentElement.style.setProperty('--editor-height', `${editorHeight}px`);
  }, [sidebarWidth, editorHeight]);

  return {
    sidebarWidth,
    editorHeight,
    handleSidebarMouseDown,
    handleEditorMouseDown,
  };
};

// =========================================

src/stores/useTabsStore.js

import { create } from 'zustand';
import { format } from 'sql-formatter';
import toast from 'react-hot-toast';

export const useTabsStore = create((set, get) => ({
  tabs: [{ id: 1, title: 'Query 1', query: '', results: [] }],
  activeTabId: 1,
  setTabs: (tabs) => set({ tabs }),
  setActiveTabId: (id) => set({ activeTabId: id }),
  updateQuery: (newQuery) => {
    set((state) => ({
      tabs: state.tabs.map((t) => (t.id === state.activeTabId ? { ...t, query: newQuery } : t)),
    }));
  },
  executeQuery: async (query) => {
    if (!query.trim()) return [];
    try {
      // Êú™Êù•ÊõøÊç¢‰∏∫ÁúüÂÆû API: const res = await fetch('/api/query/execute', { body: JSON.stringify({ query }) });
      // return res.json().results;
      toast.loading('ÊâßË°åÊü•ËØ¢‰∏≠...');
      // Mock Âª∂Ëøü
      await new Promise((resolve) => setTimeout(resolve, 500));
      toast.success('Êü•ËØ¢ÊâßË°åÊàêÂäü');
      return [
        { id: 1, name: 'Alice', age: 20, email: 'alice@example.com' },
        { id: 2, name: 'Bob', age: 25, email: 'bob@example.com' },
        { id: 3, name: 'Charlie', age: 30, email: 'charlie@example.com' },
      ];
    } catch (error) {
      toast.error('Êü•ËØ¢ÊâßË°åÂ§±Ë¥•');
      return [];
    }
  },
  addTab: () => {
    const newId = Date.now();
    set((state) => ({
      tabs: [
        ...state.tabs,
        { id: newId, title: `Query ${state.tabs.length + 1}`, query: '', results: [] },
      ],
      activeTabId: newId,
    }));
  },
  closeTab: (id) => {
    set((state) => {
      const newTabs = state.tabs.filter((t) => t.id !== id);
      let nextId = state.activeTabId;
      if (state.activeTabId === id) {
        nextId = newTabs.length > 0 ? newTabs[0].id : null;
      }
      return { tabs: newTabs, activeTabId: nextId };
    });
  },
  formatQuery: () => {
    set((state) => ({
      tabs: state.tabs.map((t) =>
        t.id === state.activeTabId
          ? {
              ...t,
              query: format(t.query, {
                language: 'sql',
                tabWidth: 2,
                linesBetweenQueries: 2,
              }),
            }
          : t
      ),
    }));
  },
  checkTabOverflow: (containerRef) => {
    if (containerRef.current) {
      const { scrollWidth, clientWidth } = containerRef.current;
      return scrollWidth > clientWidth;
    }
    return false;
  },
  handleTabScroll: (direction, containerRef) => {
    if (containerRef.current) {
      const container = containerRef.current;
      const scrollAmount = 200;
      if (direction === 'left') {
        container.scrollLeft = Math.max(0, container.scrollLeft - scrollAmount);
      } else {
        container.scrollLeft = Math.min(
          container.scrollWidth - container.clientWidth,
          container.scrollLeft + scrollAmount
        );
      }
    }
  },
}));

// =========================================

src/stores/useTreeConfigStore.js

import { create } from 'zustand';

export const useTreeConfigStore = create((set, get) => ({
  configs: {},  // { dbType: configJson }
  getConfig: (dbType) => get().configs[dbType],
  setConfig: (dbType, config) => set((state) => ({
    configs: { ...state.configs, [dbType]: config }
  })),
  // Âä†ËΩΩÈÖçÁΩÆÔºàÂú®ËøûÊé•ÂàõÂª∫/ÊµãËØïÊó∂Ë∞ÉÁî®Ôºâ
  loadConfigForConnection: async (connId) => {
    try {
      const response = await fetch(`/api/config/connections/${connId}/config`);
      if (!response.ok) throw new Error('Failed to load tree config');
      const config = await response.json();
      set((state) => ({
        configs: { ...state.configs, [config.dbType]: config }
      }));
      return config;
    } catch (error) {
      console.error('Error loading tree config:', error);
      return null;
    }
  },
  // ÈÄöÁî®ÔºöÊ†πÊçÆËäÇÁÇπ config Ëé∑Âèñ‰∏ã‰∏ÄÂ±ÇÈÖçÁΩÆ
  getNextLevelConfig: (currentConfig, subType) => {
    if (!currentConfig.nextLevel) return null;
    const next = currentConfig.nextLevel;
    if (subType && next.subTypes) {  // YAML ‰∏≠ nextLevel ÂèØÊúâ subTypes
      return next.subTypes[subType] || next;
    }
    return next;
  },
  // Ëé∑ÂèñËÅöÂêàÂàÜÁªÑÈÖçÁΩÆ
  getGroupByConfigs: (config) => config.groupBy || {},
  // Ëé∑Âèñ extraLevelsÔºàÂπ∂Ë°åÂ±ÇÔºâ
  getExtraLevels: (config) => config.extraLevels || [],
  // ÊûÑÂª∫ËôöÊãüËÅöÂêàËäÇÁÇπ
  buildVirtualGroupNode: (groupKey, parentNode, treeConfig) => {
    const groupConfigs = get().getGroupByConfigs(treeConfig);
    const groupConfig = groupConfigs[groupKey];
    if (!groupConfig) return null;
    return {
      id: `${parentNode.id}::group::${groupKey}`,
      parentId: parentNode.id,
      name: groupConfig.label,
      type: groupConfig.type,  // e.g., "table_group"
      config: {
        ...groupConfig,
        actions: groupConfig.actions || parentNode.config.actions,
        icon: groupConfig.icon
      },
      virtual: true,  // Ê†áËÆ∞ËôöÊãüËäÇÁÇπ
      children: [],  // ÊáíÂä†ËΩΩ
      connected: parentNode.connected
    };
  }
}));

// =========================================

src/stores/useTreeStore.js

import { create } from 'zustand';
import { findNode } from '../utils/treeUtils';  // ÂØºÂÖ•ËæÖÂä©ÂáΩÊï∞

export const useTreeStore = create((set, get) => ({
  treeData: [],
  setTreeData: (data) => set({ treeData: data }),
  refreshTree: async () => {
    try {
      const response = await fetch('/api/config/tree');
      if (!response.ok) throw new Error('Failed to fetch tree data');
      const { data } = await response.json();
      // data ‰∏≠ÁöÑËäÇÁÇπÂ∑≤Â∏¶ configÔºàÂêéÁ´ØÊ≥®ÂÖ•Ôºâ
      set({ treeData: data || [] });
    } catch (error) {
      console.error('Error fetching tree data:', error);
      set({ treeData: [] });
    }
  },
  // Êñ∞Â¢ûÔºö‰∏∫ËøûÊé•Âä†ËΩΩÈÖçÁΩÆÔºàÂú® connectDatabase Êó∂Ë∞ÉÁî®Ôºâ
  loadTreeConfig: async (connId) => {
    const treeConfigStore = window.treeConfigStore || { getState: () => ({ loadConfigForConnection: async () => {} }) };  // ÂÖ®Â±Ä fallback
    await treeConfigStore.getState().loadConfigForConnection(connId);
  },
  updateTreePath: (targetId, updaterFn) => {
    set((state) => {
      const newTree = JSON.parse(JSON.stringify(state.treeData));
      const targetNode = findNode(newTree, targetId);
      if (targetNode) {
        const updated = updaterFn({ ...targetNode });
        Object.assign(targetNode, updated);
      }
      return { treeData: newTree };
    });
  },
  deleteNode: (nodeId) => {
    set((state) => {
      const newTree = JSON.parse(JSON.stringify(state.treeData));
      function deleteRecursive(nodes) {
        if (!Array.isArray(nodes)) return false;
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i] && nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
          }
          if (nodes[i] && nodes[i].children && deleteRecursive(nodes[i].children)) {
            return true;
          }
        }
        return false;
      }
      deleteRecursive(newTree);
      return { treeData: newTree };
    });
  },
}));

// =========================================

src/utils/treeUtils.js

// src/utils/treeUtils.js
import fileGroupIcon from '../public/icons/left_tree/file_group_1.svg';
import folderIcon from '../public/icons/left_tree/folder_1.svg';
import folderOpenIcon from '../public/icons/left_tree/folder_open_1.svg';
import dbIcon from '../public/icons/left_tree/db_1.svg';
import schemaIcon from '../public/icons/left_tree/schema_1.svg';
import tableIcon from '../public/icons/left_tree/table_1.svg';
import viewIcon from '../public/icons/left_tree/view_1.svg';
import functionIcon from '../public/icons/left_tree/function_1.svg';

import pgsqlIcon from '../public/icons/db/postgresql_icon_3.svg';
import mysqlIcon from '../public/icons/db/mysql_icon_2.svg';
import oracleIcon from '../public/icons/db/oracle_icon_3.svg';
import sqlserverIcon from '../public/icons/db/sqlserver_icon_1.svg';

// Êñ∞Â¢ûÔºö‰ªé store ÂØºÂÖ•ÔºàÂÖ®Â±Ä‰ΩøÁî®Ôºâ
const treeConfigStore = window.treeConfigStore || { getState: () => ({ getConfig: () => ({}), getNextLevelConfig: () => ({}), getGroupByConfigs: () => ({}), getExtraLevels: () => [], buildVirtualGroupNode: () => ({}) }) };

// ÂõæÊ†áÔºö‰ºòÂÖàËäÇÁÇπ config.iconÔºåÂêéÂ§áÊóßÈÄªËæë
export const getNodeIcon = (node) => {
  return node.config?.icon || (() => {
    if (node.type === 'connection') {
      switch (node.dbType) {
        case 'POSTGRESQL': return pgsqlIcon;
        case 'MYSQL': return mysqlIcon;
        case 'ORACLE': return oracleIcon;
        case 'SQLSERVER': return sqlserverIcon;
        default: return dbIcon;
      }
    }
    if (node.type === 'folder') return node.expanded ? folderOpenIcon : folderIcon;
    if (node.type === 'database') return dbIcon;
    if (node.type === 'schema') return schemaIcon;
    if (node.type === 'table') return tableIcon;
    if (node.type === 'view') return viewIcon;
    if (node.type === 'function') return functionIcon;
    return fileGroupIcon;
  })();
};

// Â±ïÂºÄÂõæÊ†áÔºö‰∏çÂèòÔºå‰ΩÜÊ£ÄÊü• virtual ËäÇÁÇπ
export const getExpandIcon = (node) => {
  if ((node.children && node.children.length > 0) || node.virtual) {  // ÊîØÊåÅËôöÊãüËäÇÁÇπ
    if (node.type === 'folder' || node.type === 'connection' || node.type === 'database' || node.type === 'schema' || node.type.includes('_group')) {
      return node.expanded ? '‚ñº' : '‚ñ∂';
    }
  }
  return '';
};

// ÈÄöÁî®Âä†ËΩΩÂ≠êËäÇÁÇπÔºöÊ†πÊçÆ config.apiEndpoint/sqlQuery ÊûÑÂª∫ÔºàÂêéÁ´ØÂ§ÑÁêÜ sqlQueryÔºâ
export const loadNodeChildren = async (node) => {
  if (!node.connected) {
    console.warn('ËäÇÁÇπÊú™ËøûÊé•ÔºåÊó†Ê≥ïÂä†ËΩΩÂ≠êËäÇÁÇπ');
    return { ...node, children: [] };
  }

  const config = node.config;
  if (!config) {
    console.warn('No config in node');
    return { ...node, children: [] };
  }

  // ÊûÑÂª∫Ë∑ØÂæÑÔºö‰ªé node.id Ëß£Êûê (e.g., "conn123::database::mydb::schema::public" -> "database/mydb/schema/public")
  const pathSegments = node.id.split('::').slice(1);  // ÂéªÊéâ connId
  const path = pathSegments.join('/');

  // URLÔºö‰ΩøÁî®ÈÄöÁî®Êé•Âè£ÔºåÂêéÁ´ØÊ†πÊçÆ path Âíå config.sqlQuery ÊâßË°å
  const url = `/api/meta/${encodeURIComponent(node.parentId || node.id.split('::')[0])}/${path}/children`;

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(await response.text());
    let { data: { items } } = await response.json();

    // Â§ÑÁêÜËÅöÂêàÂ±ÇÔºöÂ¶ÇÊûúÊúâ groupByÔºåÂàõÂª∫ËôöÊãü group ËäÇÁÇπÔºåÂπ∂‰∏∫ÂÖ∂Âä†ËΩΩ children
    const groupByConfigs = treeConfigStore.getState().getGroupByConfigs(config);
    if (groupByConfigs && Object.keys(groupByConfigs).length > 0) {
      items = [];  // Ê∏ÖÁ©∫ÔºåÊõøÊç¢‰∏∫ group ËäÇÁÇπ
      for (const groupKey of Object.keys(groupByConfigs)) {  // Êîπ‰∏∫ for...of ‰ª•ÊîØÊåÅ await
        const groupNode = treeConfigStore.getState().buildVirtualGroupNode(groupKey, node, config);
        if (groupNode) {
          // ÈÄíÂΩíÂä†ËΩΩ group ÁöÑ childrenÔºà‰ΩøÁî® group sqlQueryÔºâ
          const groupChildren = await loadNodeChildrenForGroup(groupNode, node);  // ÂÜÖÈÉ®ÂáΩÊï∞
          groupNode.children = groupChildren;
          items.push(groupNode);
        }
      }
    } else {
      // ÊôÆÈÄöÂ±ÇÔºöÊ≥®ÂÖ•‰∏ã‰∏ÄÂ±Ç config
      const nextConfig = treeConfigStore.getState().getNextLevelConfig(config, node.subType);
      items = items.map((item) => ({
        ...item,
        parentId: node.id,
        connected: node.connected,
        config: nextConfig ? { ...nextConfig, ...item.config } : { type: item.type, icon: nextConfig?.icon }
      }));
    }

    // Ê≥®ÂÖ• extraLevelsÔºà‰ªÖ connection Â±ÇÔºâ
    if (node.type === 'connection') {
      const extraConfigs = treeConfigStore.getState().getExtraLevels(config);
      const extraNodes = extraConfigs
        .filter((extra) => extra.position === 'connection')
        .map((extra) => ({
          id: `${node.id}::extra::${extra.type}`,
          parentId: node.id,
          name: extra.label,
          type: extra.type,
          config: extra,
          children: [],  // ÊáíÂä†ËΩΩ
          connected: node.connected
        }));
      items = [...items, ...extraNodes];
    }

    return { ...node, expanded: true, children: items };
  } catch (error) {
    console.error('Âä†ËΩΩÂ≠êËäÇÁÇπÂ§±Ë¥•:', error);
    return { ...node, children: [], expanded: false };
  }
};

// ÂÜÖÈÉ®Ôºö‰∏∫ group Âä†ËΩΩ childrenÔºàÈÄíÂΩíË∞ÉÁî® loadNodeChildrenÔºå‰ΩÜË∑ØÂæÑË∞ÉÊï¥Ôºâ
const loadNodeChildrenForGroup = async (groupNode, parentNode) => {
  const groupPath = `${parentNode.id.split('::').slice(1).join('/')}/group/${groupNode.id.split('::').pop()}`;
  const groupUrl = `/api/meta/${encodeURIComponent(parentNode.id.split('::')[0])}/${groupPath}/children`;
  try {
    const response = await fetch(groupUrl);
    if (!response.ok) throw new Error(await response.text());
    const { data: { items } } = await response.json();
    const childConfig = groupNode.config.childConfig;
    return items.map((item) => ({
      ...item,
      parentId: groupNode.id,
      connected: parentNode.connected,
      config: childConfig ? { ...childConfig, ...item.config } : { type: item.type }
    }));
  } catch (error) {
    console.error('Âä†ËΩΩ group Â≠êËäÇÁÇπÂ§±Ë¥•:', error);
    return [];
  }
};

// findNode, findConnectionId, updateTreePath ‰∏çÂèò
export const findNode = (nodes, id) => {
  if (!Array.isArray(nodes)) return null;
  for (let node of nodes) {
    if (node && node.id === id) return node;
    if (node && node.children) {
      const found = findNode(node.children, id);
      if (found) return found;
    }
  }
  return null;
};

export const findConnectionId = (nodeId, treeData) => {
  const findAncestor = (nodes, targetId) => {
    for (let node of nodes) {
      if (node.id === targetId && node.type === 'connection') return node.id;
      if (node.children) {
        const found = findAncestor(node.children, targetId);
        if (found) return found;
      }
    }
    return null;
  };
  return findAncestor(treeData, nodeId) || null;
};

export const updateTreePath = (treeData, targetId, updaterFn) => {
  const newTree = JSON.parse(JSON.stringify(treeData));
  const targetNode = findNode(newTree, targetId);
  if (targetNode) Object.assign(targetNode, updaterFn({ ...targetNode }));
  return newTree;
};

// =========================================

vite.config.js

// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:8080';

export default defineConfig({
  plugins: [react()],
  define: {
    'import.meta.env.API_BASE_URL': JSON.stringify('/api'), // ÂºÄÂèëÊ®°Âºè‰ΩøÁî® /api
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: API_BASE_URL,
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''), // ÂéªÊéâ /api ÂâçÁºÄ
      },
    },
  },
});


// =========================================

