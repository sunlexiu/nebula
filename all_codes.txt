pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.deego</groupId>
    <artifactId>nebula-backend</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>17</java.version>
        <lombok.version>1.18.30</lombok.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </dependency>
        <dependency>
            <groupId>org.yaml</groupId>
            <artifactId>snakeyaml</artifactId>
            <version>2.0</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-yaml</artifactId>
            <version>2.17.0</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

// =========================================

src/main/java/com/deego/common/ApiResponse.java

package com.deego.common;

import lombok.Data;

import java.time.Instant;

/**
 * 统一 API 响应包装。
 */
@Data
public class ApiResponse<T> {
	/* getters / setters */
	private boolean success;
	private String code;
	private String message;
	private String path;
	private String timestamp;
	private T data;

	public static <T> ApiResponse<T> ok(T data) {
		return ok(data, "OK");
	}

	public static <T> ApiResponse<T> ok(T data, String message) {
		ApiResponse<T> r = new ApiResponse<>();
		r.success = true;
		r.code = "OK";
		r.message = message;
		r.timestamp = Instant.now().toString();
		r.data = data;
		return r;
	}

	public static <T> ApiResponse<T> error(String code, String message) {
		ApiResponse<T> r = new ApiResponse<>();
		r.success = false;
		r.code = code;
		r.message = message;
		r.timestamp = Instant.now().toString();
		return r;
	}

	public static <T> Builder<T> builder() {
		return new Builder<>();
	}

	public static class Builder<T> {
		private final ApiResponse<T> r = new ApiResponse<>();

		public Builder<T> success(boolean v) {
			r.success = v;
			return this;
		}

		public Builder<T> code(String v) {
			r.code = v;
			return this;
		}

		public Builder<T> message(String v) {
			r.message = v;
			return this;
		}

		public Builder<T> path(String v) {
			r.path = v;
			return this;
		}

		public Builder<T> timestamp(String v) {
			r.timestamp = v;
			return this;
		}

		public Builder<T> data(T v) {
			r.data = v;
			return this;
		}

		public ApiResponse<T> build() {
			return r;
		}
	}

}

// =========================================

src/main/java/com/deego/common/ErrorCode.java

package com.deego.common;

/**
 * 错误码枚举
 */
public enum ErrorCode {
	SUCCESS("200", "成功"),
	SYSTEM_ERROR("500", "系统错误"),
	PARAM_ERROR("400", "参数错误"),
	NOT_FOUND("404", "资源不存在");

	private final String code;
	private final String message;

	ErrorCode(String code, String message) {
		this.code = code;
		this.message = message;
	}

	public String getCode() {
		return code;
	}

	public String getMessage() {
		return message;
	}
}

// =========================================

src/main/java/com/deego/common/GlobalResponseAdvice.java

package com.deego.common;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.MethodParameter;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.http.server.ServletServerHttpResponse;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

/**
 * 全局返回/异常统一封装： - 成功：将非 ApiResponse 的返回统一包装为 ApiResponse.ok(data) - 异常：统一转为 ApiResponse.error(...) - 特殊处理：String、ResponseEntity、文件下载（attachment）不二次包装
 */
@RestControllerAdvice
@Slf4j
public class GlobalResponseAdvice implements ResponseBodyAdvice<Object> {

	private final ObjectMapper objectMapper = new ObjectMapper();

	/* ================== 统一返回包装 ================== */

	@Override
	public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
		return ResponseEntity.class.isAssignableFrom(returnType.getParameterType());
	}

	@Override
	public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
			Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {

		// 如果是文件下载或明确的附件，直接透传
		if (isAttachment(response))
			return body;

		// 已经是统一结构，直接返回
		if (body instanceof ApiResponse<?>)
			return body;

		// 对 String 特殊处理（避免 StringHttpMessageConverter 报错）
		if (body instanceof String s) {
			try {
				return objectMapper.writeValueAsString(ApiResponse.ok(s));
			} catch (JsonProcessingException e) {
				return s; // 回退：不阻断原始返回
			}
		}

		// 对 ResponseEntity 已在 supports 中排除；但稳妥起见再次判断
		if (body instanceof ResponseEntity<?>)
			return body;

		// 其他常规对象统一包装
		return ApiResponse.ok(body);
	}

	private boolean isAttachment(ServerHttpResponse response) {
		try {
			HttpHeaders headers = response.getHeaders();
			// 部分容器此处可能为不可变 headers，可从 Servlet 层再兜底判断
			ContentDisposition cd = headers.getContentDisposition();
			if (cd.isAttachment())
				return true;

			if (response instanceof ServletServerHttpResponse servletResp) {
				String disp = servletResp.getServletResponse().getHeader(HttpHeaders.CONTENT_DISPOSITION);
				if (disp != null && disp.toLowerCase().contains("attachment"))
					return true;
			}

			MediaType mt = headers.getContentType();
			// 常见的二进制、octet-stream 直接透传
			if (MediaType.APPLICATION_OCTET_STREAM.equals(mt))
				return true;
		} catch (Exception ex) {
			log.error("Error in isAttachment: ", ex);
		}
		return false;
	}
}

// =========================================

src/main/java/com/deego/config/Actions.java

package com.deego.config;

import lombok.Data;
import java.util.List;

@Data
public class Actions {
	private PrimaryAction primary;
	private List<MenuAction> menu;
}

// =========================================

src/main/java/com/deego/config/ChildConfig.java

package com.deego.config;

import lombok.Data;

@Data
public class ChildConfig {
	private String type;
	private String icon;
	private Actions actions;
}

// =========================================

src/main/java/com/deego/config/DbConfig.java

package com.deego.config;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;
import java.util.Map;  // 改为 Map

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class DbConfig {
	@JsonProperty("icon")
	private String icon;

	@JsonProperty("levels")
	private List<Level> levels;

	@JsonProperty("extraLevels")
	private Map<String, ExtraLevel> extraLevels;
}

// =========================================

src/main/java/com/deego/config/ExtraLevel.java

package com.deego.config;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class ExtraLevel {
	@JsonProperty("type")
	private String type;

	@JsonProperty("label")
	private String label;

	@JsonProperty("icon")
	private String icon;

	@JsonProperty("sqlQuery")
	private String sqlQuery;

	@JsonProperty("actions")
	private Actions actions;

	@JsonProperty("position")
	private String position;
}

// =========================================

src/main/java/com/deego/config/GroupByConfig.java

package com.deego.config;

import lombok.Data;

@Data
public class GroupByConfig {
	private String type;
	private String label;
	private String icon;
	private String sqlQuery;
	private Actions actions;
	private ChildConfig childConfig;
}

// =========================================

src/main/java/com/deego/config/Level.java

package com.deego.config;

import lombok.Data;
import java.util.List;
import java.util.Map;

@Data
public class Level {
	private String type;
	private String label;
	private String icon;
	private String sqlQuery;
	private Actions actions;
	private String nextLevel;
	private Map<String, GroupByConfig> groupBy;
}

// =========================================

src/main/java/com/deego/config/MenuAction.java

package com.deego.config;

import lombok.Data;

@Data
public class MenuAction {
	private String label;
	private String icon;
	private String handler;
	private String type; // separator
	private String variant; // danger
}

// =========================================

src/main/java/com/deego/config/PrimaryAction.java

package com.deego.config;

import lombok.Data;

@Data
public class PrimaryAction {
	private String label;
	private String icon;
	private String handler;
}

// =========================================

src/main/java/com/deego/config/TreeConfig.java

package com.deego.config;

import lombok.Data;
import java.util.List;
import java.util.Map;

@Data
public class TreeConfig {
	private Map<String, DbConfig> treeConfigs;
}

// =========================================

src/main/java/com/deego/config/TreeConfigLoader.java

package com.deego.config;

import com.deego.exception.BizException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;
import jakarta.annotation.PostConstruct;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;

import java.io.IOException;

/**
 * YAML 配置加载器，使用 Jackson YamlMapper 自动映射到 POJO。
 */
@Component
@Slf4j
public class TreeConfigLoader {

	@Value("${deego.tree-config}")
	private Resource configResource;

	@Getter
	private TreeConfig treeConfig;

	@PostConstruct
	public void loadConfig() {
		YAMLMapper yamlMapper = new YAMLMapper(new YAMLFactory());
		try {
			// 直接反序列化为 TreeConfig POJO
			treeConfig = yamlMapper.readValue(configResource.getInputStream(), TreeConfig.class);
			log.info("Tree config loaded: {}", treeConfig.getTreeConfigs().keySet());
		} catch (JsonMappingException e) {
			throw new BizException(e);
		} catch (IOException e) {
			log.error("Failed to load tree-config.yml", e);
			throw new BizException(e);
		}
	}

	public DbConfig getDbConfig(String dbType) {
		return treeConfig.getTreeConfigs().get(dbType);
	}
}

// =========================================

src/main/java/com/deego/controller/ConfigController.java

package com.deego.controller;

import com.deego.model.Connection;
import com.deego.model.Folder;
import com.deego.service.ConnectionService;
import com.deego.service.FolderService;
import com.deego.service.TreeService;
import com.deego.utils.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/config")
public class ConfigController {
	@Autowired
	private ConnectionService connectionService;
	@Autowired
	private TreeService treeService;
	@Autowired
	private FolderService folderService;
	@Autowired
	private BeanUtils beanUtils;

	@GetMapping("/tree")
	public ResponseEntity<List<Map<String, Object>>> getTree() {
		return ResponseEntity.ok(treeService.getTreeData().stream().map(beanUtils::beanToMap).toList());
	}

	@PostMapping("/folders")
	public ResponseEntity<Folder> createOrUpdateFolder(@RequestBody Folder folder) {
		if (folder.getId() != null) {
			// 重命名：更新 name
			Optional<Folder> existing = folderService.getFolder(folder.getId());
			if (existing.isPresent()) {
				existing.get().setName(folder.getName());
				return ResponseEntity.ok(folderService.createOrUpdateFolder(existing.get()));
			}
		}
		// 新建
		return ResponseEntity.ok(folderService.createOrUpdateFolder(folder));
	}

	// 新增：/api/config/folders/{id} (DELETE)
	@DeleteMapping("/folders/{id}")
	public ResponseEntity<Void> deleteFolder(@PathVariable String id) {
		folderService.deleteFolder(id);
		return ResponseEntity.noContent().build();
	}

	// 新增：/api/config/folders (GET: 所有文件夹，未来用于树构建)
	@GetMapping("/folders")
	public ResponseEntity<List<Folder>> getFolders() {
		return ResponseEntity.ok(folderService.getAllFolders());
	}

	@PostMapping("/connections")
	public ResponseEntity<Connection> createConnection(@RequestBody Connection conn) {
		return ResponseEntity.ok(connectionService.createConnection(conn));
	}

	@GetMapping("/connections")
	public ResponseEntity<List<Connection>> getConnections() {
		return ResponseEntity.ok(connectionService.getAllConnections());
	}

	@PutMapping("/connections/{id}")
	public ResponseEntity<Connection> updateConnection(@PathVariable String id, @RequestBody Connection update) {
		Connection updated = connectionService.updateConnection(id, update);
		return updated != null ? ResponseEntity.ok(updated) : ResponseEntity.notFound().build();
	}

	@DeleteMapping("/connections/{id}")
	public ResponseEntity<Void> deleteConnection(@PathVariable String id) {
		connectionService.deleteConnection(id);
		return ResponseEntity.noContent().build();
	}

	@PostMapping("/connections/test")
	public ResponseEntity<String> testConnection(@RequestBody Connection conn) {
		return ResponseEntity.ok(connectionService.testConnection(conn));
	}

	@GetMapping("/connections/{id}/test")
	public ResponseEntity<String> testConnection(@PathVariable String id) {
		Optional<Connection> conn = connectionService.getConnection(id);
		return conn.map(connection -> ResponseEntity.ok(connectionService.testConnection(connection))).orElseGet(() -> ResponseEntity.notFound().build());
	}

	@GetMapping("/connections/{id}/config")
	public ResponseEntity<Map<String, Object>> getConfig(@PathVariable String id) {
		// 返回 YAML config for conn (简化，返回全 POSTGRESQL config)
		Map<String, Object> config = Map.of("dbType", "POSTGRESQL", "actions", Map.of()); // 从 loader
		return ResponseEntity.ok(config);
	}
}

// =========================================

src/main/java/com/deego/controller/MetaController.java

package com.deego.controller;

import com.deego.service.TreeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/meta")
public class MetaController {
	@Autowired
	private TreeService treeService;

	@GetMapping("/{connId}/{path}/children")
	public ResponseEntity<Map<String, List<Map<String, Object>>>> loadChildren(@PathVariable String connId, @PathVariable String path) {
		List<Map<String, Object>> children = treeService.loadChildren(connId, path);
		Map<String, List<Map<String, Object>>> response = Map.of("data", children);
		return ResponseEntity.ok(response);
	}
}

// =========================================

src/main/java/com/deego/controller/MoveController.java

package com.deego.controller;

import com.deego.service.FolderService;
import com.deego.service.ConnectionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.Map;

@RestController
@RequestMapping("/api/config")
public class MoveController {

	@Autowired
	private FolderService folderService;

	@Autowired
	private ConnectionService connectionService;

	/**
	 * /api/config/move-node (POST): 移动节点（文件夹或连接）。
	 * body: {sourceId: "...", targetParentId: null/123, type: "folder"/"connection"}
	 */
	@PostMapping("/move-node")
	public ResponseEntity<String> moveNode(@RequestBody Map<String, Object> request) {
		String sourceId = (String) request.get("sourceId");
		String targetParentId = request.get("targetParentId") != null ? (String) request.get("targetParentId") : null;
		String type = (String) request.get("type");

		try {
			if ("folder".equals(type)) {
				// 更新 Folder parentId
				String sourceFolderId =sourceId.replace("folder_", "");
				folderService.getFolder(sourceFolderId).ifPresent(folder -> {
					folder.setParentId(targetParentId);
					folderService.createOrUpdateFolder(folder);
				});
			} else if ("connection".equals(type)) {
				// 更新 Connection parentId
				connectionService.getConnection(sourceId).ifPresent(conn -> {
					conn.setParentId(targetParentId);
					connectionService.updateConnection(sourceId, conn);  // 复用更新
				});
			}
			return ResponseEntity.ok("Node moved successfully");
		} catch (Exception e) {
			return ResponseEntity.badRequest().body("Move failed: " + e.getMessage());
		}
	}
}

// =========================================

src/main/java/com/deego/controller/QueryController.java

package com.deego.controller;

import com.deego.service.ConnectionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/query")
public class QueryController {

	@Autowired
	private ConnectionService connectionService;

	/**
	 * /api/query/execute (POST): 执行 SQL 查询，返回结果。
	 * body: {connId: 1, query: "SELECT * FROM users LIMIT 1000"}
	 * 返回: {success: true, results: [...], rowCount: 10}
	 */
	@PostMapping("/execute")
	public ResponseEntity<Map<String, Object>> executeQuery(@RequestBody Map<String, Object> request) {
		String connId = (String) request.get("connId");
		String query = (String) request.get("query");

		try {
			JdbcTemplate jdbc = connectionService.getJdbcTemplate(connId);
			// 执行查询（假设 SELECT；生产加类型检查，避免 DDL）
			List<Map<String, Object>> results = jdbc.queryForList(query);
			Map<String, Object> response = Map.of(
					"success", true,
					"results", results,
					"rowCount", results.size()
			);
			return ResponseEntity.ok(response);
		} catch (Exception e) {
			Map<String, Object> error = Map.of(
					"success", false,
					"error", e.getMessage()
			);
			return ResponseEntity.badRequest().body(error);
		}
	}
}

// =========================================

src/main/java/com/deego/DeegoApplication.java

package com.deego;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DeegoApplication {
	public static void main(String[] args) {
		SpringApplication.run(DeegoApplication.class, args);
	}
}

// =========================================

src/main/java/com/deego/enums/DatabaseType.java

package com.deego.enums;

/**
 * 数据库类型枚举，支持 YAML treeConfigs 扩展。
 */
public enum DatabaseType {
	POSTGRESQL("POSTGRESQL"),
	MYSQL("MYSQL"),
	SQLSERVER("SQLSERVER"),
	ORACLE("ORACLE");

	private final String value;

	DatabaseType(String value) {
		this.value = value;
	}

	public String getValue() {
		return value;
	}

	public static DatabaseType fromValue(String value) {
		for (DatabaseType type : values()) {
			if (type.value.equalsIgnoreCase(value)) {
				return type;
			}
		}
		throw new IllegalArgumentException("Unknown database type: " + value);
	}
}

// =========================================

src/main/java/com/deego/enums/NodeType.java

package com.deego.enums;

/**
 * 节点类型枚举，基于 YAML levels/groupBy，支持路径匹配。
 */
public enum NodeType {
	FOLDER("folder"),
	CONNECTION("connection"),
	DATABASE("database"),
	SCHEMA("schema"),
	OBJECTS("objects"),
	TABLE_GROUP("table_group"),
	VIEW_GROUP("view_group"),
	FUNCTION_GROUP("function_group"),
	PUBLICATIONS("publications"),
	ROLES("roles");

	private final String value;

	NodeType(String value) {
		this.value = value;
	}

	public String getValue() {
		return value;
	}

	/**
	 * 判断 path 是否匹配当前类型（支持空 path 为 CONNECTION）。
	 */
	public boolean matches(String path) {
		return (path == null || path.isEmpty() || path.equals(value));
	}

	/**
	 * 从 path 解析类型（基于 segments[0]）。
	 */
	public static NodeType fromPath(String path) {
		if (path == null || path.isEmpty()) return CONNECTION;
		String[] segments = path.split("/");
		if (segments.length > 0) {
			for (NodeType type : values()) {
				if (type.getValue().equals(segments[0])) {
					return type;
				}
			}
		}
		return CONNECTION;  // 默认
	}
}

// =========================================

src/main/java/com/deego/enums/PlaceholderType.java

package com.deego.enums;

/**
 * SQL 占位符枚举，用于 replacePlaceholders 方法。
 */
public enum PlaceholderType {
	SCHEMA_NAME("schemaName"),
	DB_NAME("dbName"),
	CONN_ID("connId");

	private final String key;

	PlaceholderType(String key) {
		this.key = key;
	}

	public String getKey() {
		return key;
	}

	public String getValue() {
		return "{" + key + "}";  // e.g., {schemaName}
	}
}

// =========================================

src/main/java/com/deego/enums/TreePathType.java

package com.deego.enums;

/**
 * 树路径类型枚举，基于 YAML levels 定义，避免魔法字符串。
 * 支持精确匹配或空 path。
 */
public enum TreePathType {
	CONNECTION("connection"),
	DATABASE("database"),
	SCHEMA("schema"),
	OBJECTS("objects");

	private final String value;

	TreePathType(String value) {
		this.value = value;
	}

	public String getValue() {
		return value;
	}

	/**
	 * 判断 path 是否匹配当前类型（支持空 path 为 CONNECTION）。
	 */
	public boolean matches(String path) {
		return (path == null || path.isEmpty() || path.equals(value));
	}

	/**
	 * 从 path 解析类型（简化：基于 segments[0]）。
	 */
	public static TreePathType fromPath(String path) {
		if (path == null || path.isEmpty()) return CONNECTION;
		String[] segments = path.split("/");
		if (segments.length > 0) {
			for (TreePathType type : values()) {
				if (type.getValue().equals(segments[0])) {
					return type;
				}
			}
		}
		return CONNECTION;
	}
}

// =========================================

src/main/java/com/deego/exception/BizException.java

package com.deego.exception;

import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * 业务异常
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class BizException extends RuntimeException {
	private final String code;

	public BizException(String message) {
		super(message);
		this.code = "BIZ_ERROR";
	}

	public BizException(String code, String message) {
		super(message);
		this.code = code;
	}

	public BizException(Throwable cause) {
		super(cause);
		this.code = "BIZ_ERROR";
	}

	public BizException(String code, String message, Throwable cause) {
		super(message, cause);
		this.code = code;
	}

}

// =========================================

src/main/java/com/deego/handler/GlobalExceptionHandler.java

package com.deego.handler;

import com.deego.common.ApiResponse;
import com.deego.exception.BizException;
import com.deego.common.ErrorCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

import java.sql.SQLException;

/**
 * 全局异常处理器
 */
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

	@ExceptionHandler(BizException.class)
	@ResponseStatus(HttpStatus.BAD_REQUEST)
	public ResponseEntity<ApiResponse<?>> handleBizException(BizException e) {
		ApiResponse<?> response = ApiResponse.error(e.getCode(), e.getMessage());
		return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
	}

	@ExceptionHandler(SQLException.class)
	@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
	public ResponseEntity<ApiResponse<?>> handleSQLException(SQLException e) {
		ApiResponse<?> response = ApiResponse.error(ErrorCode.SYSTEM_ERROR.getCode(), "数据库操作失败: " + e.getMessage());
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
	}

	@ExceptionHandler(RuntimeException.class)
	@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
	public ResponseEntity<ApiResponse<?>> handleRuntimeException(RuntimeException e) {
		log.error("RuntimeException: ", e);
		ApiResponse<?> response = ApiResponse.error(ErrorCode.SYSTEM_ERROR.getCode(), e.getMessage());
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
	}

	@ExceptionHandler(Exception.class)
	@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
	public ResponseEntity<ApiResponse<?>> handleGenericException(Exception e) {
		log.error("Exception: ", e);
		ApiResponse<?> response = ApiResponse.error(ErrorCode.SYSTEM_ERROR.getCode(), "系统内部错误");
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
	}
}

// =========================================

src/main/java/com/deego/model/Connection.java

package com.deego.model;

import com.deego.utils.IdWorker;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "connections")
@Data
@NoArgsConstructor
public class Connection {
	@Id
	@Column(length = 32)
	private String id = IdWorker.getIdStr(); // 雪花 ID

	private String name;
	private String dbType;
	private String host;
	private Integer port;
	private String database;
	private String username;
	private String password;

	@Column(name = "parent_id")
	private String parentId;

	private Boolean connected = false;
}

// =========================================

src/main/java/com/deego/model/Folder.java

package com.deego.model;

import com.deego.utils.IdWorker;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "folders")
@Data
@NoArgsConstructor
public class Folder {
	@Id
	@Column(length = 32)
	private String id = IdWorker.getIdStr(); // 雪花 ID

	private String name;

	@Column(name = "parent_id")
	private String parentId;

	public Folder(String name, String parentId) {
		this.id = IdWorker.getIdStr();
		this.name = name;
		this.parentId = parentId;
	}
}

// =========================================

src/main/java/com/deego/model/TreeNode.java

package com.deego.model;

import com.deego.config.Actions;
import lombok.Data;

import java.util.List;

@Data
public class TreeNode {
	private String id;
	private String name;
	private String type;
	private String dbType;
	private String host;
	private Integer port;
	private String database;
	private String username;
	private String parentId;
	private Boolean connected;
	private Boolean expanded;
	private Boolean virtual;
	private String subType;
	private String icon;
	private Actions config; // YAML actions 等
	private List<TreeNode> children;
}

// =========================================

src/main/java/com/deego/repository/ConnectionRepository.java

package com.deego.repository;

import com.deego.model.Connection;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ConnectionRepository extends JpaRepository<Connection, String> {
	List<Connection> findByParentId(String parentId);
	List<Connection> findByParentIdIsNull();
}

// =========================================

src/main/java/com/deego/repository/FolderRepository.java

package com.deego.repository;

import com.deego.model.Folder;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface FolderRepository extends JpaRepository<Folder, String> {
	List<Folder> findByParentId(String parentId);
	List<Folder> findByParentIdIsNull();
}

// =========================================

src/main/java/com/deego/service/ActionService.java

package com.deego.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiConsumer;

@Service
public class ActionService {
	@Autowired
	private ConnectionService connectionService;

	private final Map<String, BiConsumer<JdbcTemplate, Map<String, Object>>> handlers = new HashMap<>();

	public ActionService() {
		// 注册 handlers (扩展点：易加新动作)
		handlers.put("refreshDatabase", (jdbc, params) -> { /* NOP, 前端刷新 */ });
		handlers.put("createNewSchema", (jdbc, params) -> {
			String schemaName = (String) params.get("schemaName");
			jdbc.update("CREATE SCHEMA IF NOT EXISTS " + schemaName);
		});
		handlers.put("exportDatabase", (jdbc, params) -> { /* 生成 DDL SQL */ });
		handlers.put("deleteDatabase", (jdbc, params) -> {
			String dbName = (String) params.get("dbName");
			jdbc.update("DROP DATABASE IF EXISTS " + dbName);
		});
		handlers.put("refreshSchema", (jdbc, params) -> { /* NOP */ });
		handlers.put("createNewTable", (jdbc, params) -> {
			// 示例：CREATE TABLE ... (params 有 DDL)
			String ddl = (String) params.get("ddl");
			jdbc.update(ddl);
		});
		handlers.put("createNewView", (jdbc, params) -> {
			String viewName = (String) params.get("viewName");
			String query = (String) params.get("query");
			jdbc.update("CREATE OR REPLACE VIEW " + viewName + " AS " + query);
		});
		handlers.put("createNewFunction", (jdbc, params) -> {
			String funcDdl = (String) params.get("ddl");
			jdbc.update(funcDdl);
		});
		handlers.put("exportSchema", (jdbc, params) -> { /* 生成 Schema DDL */ });
		handlers.put("previewTable", (jdbc, params) -> {
			String schema = (String) params.get("schemaName");
			String table = (String) params.get("objectName");
			// 返回数据：jdbc.query("SELECT * FROM " + schema + "." + table + " LIMIT 1000")
		});
		handlers.put("editTableStructure", (jdbc, params) -> { /* ALTER TABLE */ });
		handlers.put("generateTableSQL", (jdbc, params) -> { /* pg_dump */ });
		handlers.put("exportTableData", (jdbc, params) -> { /* COPY TO CSV */ });
		handlers.put("viewDefinition", (jdbc, params) -> {
			String schema = (String) params.get("schemaName");
			String view = (String) params.get("objectName");
			jdbc.queryForObject("SELECT pg_get_viewdef('" + schema + "." + view + "'::regclass)", String.class);
		});
		handlers.put("editView", (jdbc, params) -> { /* DROP + CREATE */ });
		handlers.put("generateViewSQL", (jdbc, params) -> { /* pg_get_viewdef */ });
		handlers.put("editFunction", (jdbc, params) -> { /* DROP + CREATE */ });
		handlers.put("viewFunctionSource", (jdbc, params) -> {
			String funcId = (String) params.get("objectName");
			jdbc.queryForObject("SELECT pg_get_functiondef('" + funcId + "'::regproc)", String.class);
		});
		handlers.put("testFunction", (jdbc, params) -> { /* CALL func() */ });
		handlers.put("showProperties", (jdbc, params) -> { /* DESCRIBE */ });
		handlers.put("deleteSchema", (jdbc, params) -> {
			String schemaName = (String) params.get("schemaName");
			jdbc.update("DROP SCHEMA IF EXISTS " + schemaName + " CASCADE");
		});
		handlers.put("deleteTable", (jdbc, params) -> {
			String schema = (String) params.get("schemaName");
			String table = (String) params.get("objectName");
			jdbc.update("DROP TABLE IF EXISTS " + schema + "." + table + " CASCADE");
		});
		handlers.put("deleteView", (jdbc, params) -> {
			String schema = (String) params.get("schemaName");
			String view = (String) params.get("objectName");
			jdbc.update("DROP VIEW IF EXISTS " + schema + "." + view + " CASCADE");
		});
		handlers.put("deleteFunction", (jdbc, params) -> {
			String funcId = (String) params.get("objectName");
			jdbc.update("DROP FUNCTION IF EXISTS " + funcId + " CASCADE");
		});
		handlers.put("refreshMaterializedView", (jdbc, params) -> {
			String schema = (String) params.get("schemaName");
			String mview = (String) params.get("objectName");
			jdbc.update("REFRESH MATERIALIZED VIEW " + schema + "." + mview);
		});
		handlers.put("viewPublication", (jdbc, params) -> { /* SELECT * FROM pg_publication */ });
		handlers.put("createPublication", (jdbc, params) -> {
			String pubName = (String) params.get("pubName");
			jdbc.update("CREATE PUBLICATION " + pubName + " FOR ALL TABLES");
		});
		handlers.put("deletePublication", (jdbc, params) -> {
			String pubName = (String) params.get("pubName");
			jdbc.update("DROP PUBLICATION IF EXISTS " + pubName);
		});
		handlers.put("showRoleProperties", (jdbc, params) -> { /* \du */ });
		handlers.put("createRole", (jdbc, params) -> {
			String roleName = (String) params.get("roleName");
			jdbc.update("CREATE ROLE " + roleName + " LOGIN PASSWORD 'password'");
		});
		handlers.put("deleteRole", (jdbc, params) -> {
			String roleName = (String) params.get("roleName");
			jdbc.update("DROP ROLE IF EXISTS " + roleName);
		});
	}

	// /api/db/{handler}
	public String executeAction(String handler, Map<String, Object> params) {
		String connId = (String) params.get("connectionId");
		JdbcTemplate jdbc = connectionService.getJdbcTemplate(connId);
		BiConsumer<JdbcTemplate, Map<String, Object>> action = handlers.get(handler);
		if (action != null) {
			action.accept(jdbc, params);
			return "Action '" + handler + "' executed successfully";
		}
		return "Unknown handler: " + handler;
	}
}

// =========================================

src/main/java/com/deego/service/ConnectionService.java

package com.deego.service;

import com.deego.exception.BizException;
import com.deego.model.Connection;
import com.deego.repository.ConnectionRepository;
import com.deego.utils.IdWorker;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
public class ConnectionService {
	@Autowired
	private ConnectionRepository connectionRepository;

	private final Map<String, HikariDataSource> dataSources = new HashMap<>();

	public List<Connection> getAllConnections() {
		return connectionRepository.findAll();
	}

	public Connection createConnection(Connection conn) {
		if (conn.getId() == null || conn.getId().isEmpty()) {
			conn.setId(IdWorker.getIdStr());
		}
		Connection saved = connectionRepository.save(conn);
		createDataSource(saved);
		return saved;
	}

	public Optional<Connection> getConnection(String id) {
		return connectionRepository.findById(id);
	}

	public Connection updateConnection(String id, Connection update) {
		Optional<Connection> existing = getConnection(id);
		if (existing.isPresent()) {
			Connection conn = existing.get();
			conn.setName(update.getName());
			conn.setHost(update.getHost());
			conn.setPort(update.getPort());
			conn.setDatabase(update.getDatabase());
			conn.setUsername(update.getUsername());
			conn.setPassword(update.getPassword());
			Connection saved = connectionRepository.save(conn);
			closeDataSource(id);
			createDataSource(saved);
			return saved;
		}
		return null;
	}

	public void deleteConnection(String id) {
		closeDataSource(id);
		connectionRepository.deleteById(id);
	}

	public String testConnection(Connection conn) {
		try {
			HikariDataSource ds = createTempDataSource(conn);
			new JdbcTemplate(ds).queryForObject("SELECT 1", Integer.class);
			ds.close();
			return "Connected successfully!";
		} catch (Exception e) {
			throw new BizException("Connection failed: " + e.getMessage());
		}
	}

	public JdbcTemplate getJdbcTemplate(String id) {
		HikariDataSource ds = dataSources.get(id);
		if (ds == null) {
			Optional<Connection> connOpt = getConnection(id);
			if (connOpt.isPresent()) {
				ds = createDataSource(connOpt.get());
			}
		}
		return new JdbcTemplate(ds);
	}

	private HikariDataSource createDataSource(Connection conn) {
		HikariConfig config = new HikariConfig();
		config.setJdbcUrl("jdbc:postgresql://" + conn.getHost() + ":" + conn.getPort() + "/" + conn.getDatabase());
		config.setUsername(conn.getUsername());
		config.setPassword(conn.getPassword());
		config.setDriverClassName("org.postgresql.Driver");
		HikariDataSource ds = new HikariDataSource(config);
		dataSources.put(conn.getId(), ds);
		return ds;
	}

	private HikariDataSource createTempDataSource(Connection conn) {
		HikariConfig config = new HikariConfig();
		config.setJdbcUrl("jdbc:postgresql://" + conn.getHost() + ":" + conn.getPort() + "/" + conn.getDatabase());
		config.setUsername(conn.getUsername());
		config.setPassword(conn.getPassword());
		config.setDriverClassName("org.postgresql.Driver");
		return new HikariDataSource(config);
	}

	private void closeDataSource(String id) {
		HikariDataSource ds = dataSources.remove(id);
		if (ds != null) {
			ds.close();
		}
	}
}

// =========================================

src/main/java/com/deego/service/FolderService.java

package com.deego.service;

import com.deego.model.Folder;
import com.deego.repository.FolderRepository;
import com.deego.utils.IdWorker;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@Service
public class FolderService {
	@Autowired
	private FolderRepository folderRepository;

	public List<Folder> getAllFolders() {
		return folderRepository.findAll();
	}

	public Folder createOrUpdateFolder(Folder folder) {
		if (folder.getId() == null || folder.getId().isEmpty()) {
			folder.setId(IdWorker.getIdStr());
		}
		return folderRepository.save(folder);
	}

	public Optional<Folder> getFolder(String id) {
		return folderRepository.findById(id);
	}

	public void deleteFolder(String id) {
		folderRepository.deleteById(id);
	}

	public List<Folder> getRootFolders() {
		return folderRepository.findByParentIdIsNull();
	}

	public List<Folder> getChildFolders(String parentId) {
		return folderRepository.findByParentId(parentId);
	}
}

// =========================================

src/main/java/com/deego/service/TreeService.java

package com.deego.service;

import com.deego.config.*;
import com.deego.enums.DatabaseType;
import com.deego.enums.NodeType;
import com.deego.enums.PlaceholderType;
import com.deego.model.Folder;
import com.deego.model.TreeNode;
import com.deego.utils.BeanUtils;
import com.deego.utils.IdWorker;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class TreeService {

	@Autowired
	private ConnectionService connectionService;

	@Autowired
	private TreeConfigLoader configLoader;

	@Autowired
	private BeanUtils beanUtils;

	@Autowired
	private FolderService folderService;

	public List<Map<String, Object>> getTreeData() {
		List<TreeNode> rootNodes = new ArrayList<>();
		List<Folder> rootFolders = folderService.getRootFolders();
		for (Folder folder : rootFolders) {
			rootNodes.add(buildFolderTree(folder));
		}

		List<com.deego.model.Connection> rootConns = connectionService.getAllConnections().stream()
																	  .filter(c -> c.getParentId() == null)
																	  .collect(Collectors.toList());
		for (com.deego.model.Connection conn : rootConns) {
			TreeNode connNode = toTreeNode(conn);
			connNode.setChildren(loadExtraLevelsAsTreeNodes(conn.getId()));
			rootNodes.add(connNode);
		}

		return rootNodes.stream()
						.map(beanUtils::beanToMap)
						.collect(Collectors.toList());
	}

	private TreeNode buildFolderTree(Folder folder) {
		TreeNode folderNode = toTreeNodeFromFolder(folder);
		List<Folder> childFolders = folderService.getChildFolders(folder.getId());
		List<TreeNode> childNodes = new ArrayList<>();
		for (Folder childFolder : childFolders) {
			childNodes.add(buildFolderTree(childFolder));
		}
		List<com.deego.model.Connection> childConns = connectionService.getAllConnections().stream()
																	   .filter(c -> c.getParentId() != null && c.getParentId().equals(folder.getId()))
																	   .toList();
		for (com.deego.model.Connection conn : childConns) {
			TreeNode connNode = toTreeNode(conn);
			connNode.setChildren(loadExtraLevelsAsTreeNodes(conn.getId()));
			childNodes.add(connNode);
		}
		folderNode.setChildren(childNodes);
		return folderNode;
	}

	public List<Map<String, Object>> loadChildren(String connIdStr, String path) {
		String connId = connIdStr;
		JdbcTemplate jdbc = connectionService.getJdbcTemplate(connId);
		DbConfig dbConfig = configLoader.getDbConfig(getDbType(connId));

		List<TreeNode> children = new ArrayList<>();
		String[] segments = path.split("/");
		Level currentLevel = findCurrentLevel(dbConfig.getLevels(), segments);

		try {
			if (currentLevel.getGroupBy() != null && !currentLevel.getGroupBy().isEmpty()) {
				for (Map.Entry<String, GroupByConfig> entry : currentLevel.getGroupBy().entrySet()) {
					String groupKey = entry.getKey();
					GroupByConfig group = entry.getValue();
					TreeNode groupNode = createVirtualGroupNode(groupKey, group, path, jdbc, connId);
					children.add(groupNode);
				}
			} else {
				String sql = replacePlaceholders(currentLevel.getSqlQuery(), path, segments);
				List<Map<String, Object>> rows = jdbc.queryForList(sql);
				for (Map<String, Object> row : rows) {
					TreeNode node = createLeafNode(row, currentLevel, path, connId);
					children.add(node);
				}
			}

			NodeType pathType = NodeType.fromPath(path);
			if (pathType == NodeType.CONNECTION) {
				children.addAll(loadExtraLevelsAsTreeNodes(connId));
			}

			return children.stream()
						   .map(beanUtils::beanToMap)
						   .collect(Collectors.toList());

		} catch (Exception e) {
			System.err.println("Load children failed for path: " + path + ", error: " + e.getMessage());
			throw new RuntimeException("加载子节点失败: " + e.getMessage(), e);
		}
	}

	private List<TreeNode> loadExtraLevelsAsTreeNodes(String connId) {
		List<TreeNode> extras = new ArrayList<>();
		DbConfig dbConfig = configLoader.getDbConfig(getDbType(connId));
		JdbcTemplate jdbc = connectionService.getJdbcTemplate(connId);

		if (dbConfig.getExtraLevels() != null && !dbConfig.getExtraLevels().isEmpty()) {
			for (Map.Entry<String, ExtraLevel> entry : dbConfig.getExtraLevels().entrySet()) {
				String extraKey = entry.getKey();
				ExtraLevel extra = entry.getValue();
				if (NodeType.CONNECTION.getValue().equals(extra.getPosition())) {
					try {
						String sql = replacePlaceholders(extra.getSqlQuery(), "", new String[0]);
						List<Map<String, Object>> rows = jdbc.queryForList(sql);
						for (Map<String, Object> row : rows) {
							TreeNode node = createLeafNode(row, extra, extraKey, connId);
							extras.add(node);
						}
					} catch (Exception e) {
						System.err.println("Load extra level failed: " + extra.getType() + ", error: " + e.getMessage());
					}
				}
			}
		}
		return extras;
	}

	public List<Map<String, Object>> loadExtraLevels(String connId) {
		List<TreeNode> extras = loadExtraLevelsAsTreeNodes(connId);
		return extras.stream().map(beanUtils::beanToMap).collect(Collectors.toList());
	}

	private TreeNode createVirtualGroupNode(String groupKey, GroupByConfig group, String parentPath, JdbcTemplate jdbc, String connId) {
		TreeNode groupNode = new TreeNode();
		groupNode.setId(connId + "::group::" + groupKey);
		groupNode.setName(group.getLabel());
		groupNode.setType(group.getType());
		groupNode.setVirtual(true);
		groupNode.setIcon(group.getIcon());
		groupNode.setConnected(true);
		groupNode.setConfig(getActionsFromConfig(group.getActions()));

		try {
			String sql = replacePlaceholders(group.getSqlQuery(), parentPath, parentPath.split("/"));
			List<Map<String, Object>> rows = jdbc.queryForList(sql);
			List<TreeNode> groupChildren = new ArrayList<>();
			for (Map<String, Object> row : rows) {
				TreeNode child = createLeafNode(row, group.getChildConfig(), parentPath + "/" + groupKey, connId);
				groupChildren.add(child);
			}
			groupNode.setChildren(groupChildren);
		} catch (Exception e) {
			System.err.println("Load group children failed for: " + groupKey + ", error: " + e.getMessage());
			groupNode.setChildren(Collections.emptyList());
		}

		return groupNode;
	}

	private TreeNode createLeafNode(Map<String, Object> row, Object levelConfig, String parentPath, String connId) {
		TreeNode node = new TreeNode();
		String name = (String) row.getOrDefault("name", row.get("id"));
		String rawId = (String) row.getOrDefault("id", name);
		String uniqueKey = parentPath.isEmpty() ? rawId : parentPath + "/" + rawId;
		node.setId(connId + "::" + uniqueKey);
		node.setName(name);
		node.setType(levelConfig instanceof Level ? ((Level) levelConfig).getType() : ((ChildConfig) levelConfig).getType());
		if (row.containsKey("subType")) {
			node.setSubType((String) row.get("subType"));
		}
		node.setIcon(levelConfig instanceof Level ? ((Level) levelConfig).getIcon() : ((ChildConfig) levelConfig).getIcon());
		node.setConnected(true);
		node.setExpanded(false);
		node.setConfig(getActionsFromConfig(levelConfig));
		return node;
	}

	private TreeNode toTreeNodeFromFolder(Folder folder) {
		TreeNode node = new TreeNode();
		node.setId(folder.getId());
		node.setName(folder.getName());
		node.setType(NodeType.FOLDER.getValue());
		node.setParentId(folder.getParentId());
		node.setExpanded(false);
		node.setChildren(new ArrayList<>());
		return node;
	}

	private TreeNode toTreeNode(com.deego.model.Connection conn) {
		TreeNode node = new TreeNode();
		node.setId(conn.getId());
		node.setName(conn.getName());
		node.setType(NodeType.CONNECTION.getValue());
		node.setDbType(conn.getDbType());
		node.setHost(conn.getHost());
		node.setPort(conn.getPort());
		node.setDatabase(conn.getDatabase());
		node.setUsername(conn.getUsername());
		node.setConnected(conn.getConnected());
		node.setParentId(conn.getParentId());
		node.setExpanded(false);
		node.setChildren(new ArrayList<>());

		DbConfig dbConfig = configLoader.getDbConfig(conn.getDbType());
		if (dbConfig != null) {
			node.setIcon(dbConfig.getIcon());
			node.setConfig(new Actions());
		}
		return node;
	}

	private Level findCurrentLevel(List<Level> levels, String[] segments) {
		int levelIndex = Math.min(segments.length, levels.size() - 1);
		return levels.get(levelIndex);
	}

	private String replacePlaceholders(String sql, String path, String[] segments) {
		Map<String, String> placeholders = new HashMap<>();
		if (segments.length > 1) {
			placeholders.put(PlaceholderType.SCHEMA_NAME.getKey(), segments[segments.length - 1]);
			placeholders.put(PlaceholderType.DB_NAME.getKey(), segments.length > 0 ? segments[0] : "");
		}
		for (PlaceholderType placeholder : PlaceholderType.values()) {
			String key = placeholder.getKey();
			if (placeholders.containsKey(key)) {
				sql = sql.replace(placeholder.getValue(), placeholders.get(key));
			}
		}
		return sql;
	}

	private Actions getActionsFromConfig(Object config) {
		if (config instanceof Level) {
			return ((Level) config).getActions();
		} else if (config instanceof ChildConfig) {
			return ((ChildConfig) config).getActions();
		} else if (config instanceof ExtraLevel) {
			return ((ExtraLevel) config).getActions();
		}
		return new Actions();
	}

	private String getDbType(String connId) {
		return connectionService.getConnection(connId)
								.map(com.deego.model.Connection::getDbType)
								.map(DatabaseType::fromValue)
								.map(DatabaseType::getValue)
								.orElse(DatabaseType.POSTGRESQL.getValue());
	}
}

// =========================================

src/main/java/com/deego/utils/BeanUtils.java

package com.deego.utils;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Bean 与 Map 互转工具类，使用 Jackson ObjectMapper 处理。
 * 支持嵌套对象递归转换，忽略 null 值。
 */
@Component
public class BeanUtils {

	private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

	/**
	 * Bean 转为 Map<String, Object>，递归处理嵌套 Bean/List/Map。
	 *
	 * @param bean 要转换的 Bean 对象
	 * @return Map<String, Object>
	 */
	public Map<String, Object> beanToMap(Object bean) {
		if (bean == null) {
			return new HashMap<>();
		}
		try {
			JsonNode jsonNode = OBJECT_MAPPER.valueToTree(bean);
			return jsonNodeToMap(jsonNode);
		} catch (Exception e) {
			throw new RuntimeException("Bean to Map conversion failed: " + e.getMessage(), e);
		}
	}

	/**
	 * Map 转为 Bean，支持泛型。
	 *
	 * @param map  Map 数据
	 * @param clazz 目标 Bean 类
	 * @param <T>  泛型类型
	 * @return T 实例
	 */
	public <T> T mapToBean(Map<String, Object> map, Class<T> clazz) {
		if (map == null || map.isEmpty()) {
			try {
				return clazz.getDeclaredConstructor().newInstance();
			} catch (Exception e) {
				throw new RuntimeException("Failed to create empty instance of " + clazz.getSimpleName(), e);
			}
		}
		try {
			return OBJECT_MAPPER.convertValue(map, clazz);
		} catch (Exception e) {
			throw new RuntimeException("Map to Bean conversion failed for " + clazz.getSimpleName() + ": " + e.getMessage(), e);
		}
	}

	/**
	 * 内部：JsonNode 递归转为 Map（处理嵌套）。
	 */
	private Map<String, Object> jsonNodeToMap(JsonNode node) {
		Map<String, Object> map = new HashMap<>();
		if (node.isObject()) {
			Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
			while (fields.hasNext()) {
				Map.Entry<String, JsonNode> entry = fields.next();
				String key = entry.getKey();
				JsonNode value = entry.getValue();
				if (!value.isNull()) {
					map.put(key, jsonNodeToValue(value));
				}
			}
		}
		return map;
	}

	/**
	 * 内部：JsonNode 转为简单值或递归 Map/List。
	 */
	private Object jsonNodeToValue(JsonNode node) {
		if (node.isObject()) {
			return jsonNodeToMap(node);
		} else if (node.isArray()) {
			return OBJECT_MAPPER.convertValue(node, List.class);
		} else {
			return OBJECT_MAPPER.convertValue(node, Object.class);
		}
	}
}

// =========================================

src/main/java/com/deego/utils/IdWorker.java

package com.deego.utils;

/**
 * 极简雪花算法（Snowflake ID）- 零依赖
 * 64 位：1 位符号 + 41 位时间戳 + 10 位机器ID + 12 位序列号
 * 每毫秒支持 4096 个 ID，足够数据库管理软件使用
 */
public class IdWorker {
	private final long workerId;
	private final long datacenterId;
	private long sequence = 0L;

	private final long twepoch = 1288834974657L; // 起始时间戳

	private final long workerIdBits = 5L;
	private final long datacenterIdBits = 5L;
	private final long maxWorkerId = ~(-1L << workerIdBits);
	private final long maxDatacenterId = ~(-1L << datacenterIdBits);
	private final long sequenceBits = 12L;

	private final long workerIdShift = sequenceBits;
	private final long datacenterIdShift = sequenceBits + workerIdBits;
	private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
	private final long sequenceMask = ~(-1L << sequenceBits);

	private long lastTimestamp = -1L;

	public IdWorker(long workerId, long datacenterId) {
		if (workerId > maxWorkerId || workerId < 0) {
			throw new IllegalArgumentException("worker Id can't be greater than " + maxWorkerId + " or less than 0");
		}
		if (datacenterId > maxDatacenterId || datacenterId < 0) {
			throw new IllegalArgumentException("datacenter Id can't be greater than " + maxDatacenterId + " or less than 0");
		}
		this.workerId = workerId;
		this.datacenterId = datacenterId;
	}

	public synchronized long nextId() {
		long timestamp = timeGen();

		if (timestamp < lastTimestamp) {
			throw new RuntimeException("Clock moved backwards.");
		}

		if (lastTimestamp == timestamp) {
			sequence = (sequence + 1) & sequenceMask;
			if (sequence == 0) {
				timestamp = tilNextMillis(lastTimestamp);
			}
		} else {
			sequence = 0L;
		}

		lastTimestamp = timestamp;

		return ((timestamp - twepoch) << timestampLeftShift) |
				(datacenterId << datacenterIdShift) |
				(workerId << workerIdShift) |
				sequence;
	}

	private long tilNextMillis(long lastTimestamp) {
		long timestamp = timeGen();
		while (timestamp <= lastTimestamp) {
			timestamp = timeGen();
		}
		return timestamp;
	}

	private long timeGen() {
		return System.currentTimeMillis();
	}

	// 静态实例（单机使用，workerId=1, datacenterId=1）
	private static final IdWorker INSTANCE = new IdWorker(1, 1);

	public static long getId() {
		return INSTANCE.nextId();
	}

	public static String getIdStr() {
		return String.valueOf(INSTANCE.nextId());
	}
}

// =========================================

src/main/java/com/deego/utils/SqlUtils.java

package com.deego.utils;

import java.util.Map;

public class SqlUtils {
	public static String replacePlaceholders(String sql, Map<String, String> placeholders) {
		for (Map.Entry<String, String> entry : placeholders.entrySet()) {
			sql = sql.replace("{" + entry.getKey() + "}", entry.getValue());
		}
		return sql;
	}
}

// =========================================

src/main/resources/application.yml

server:
  port: 8080

spring:
  datasource:
    url: jdbc:h2:file:./data/deego;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password:
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  h2:
    console:
      enabled: true

# YAML 配置路径（classpath）
deego:
  tree-config: classpath:config/tree-config.yml

logging:
  level:
    com.deego: DEBUG
    org.springframework.jdbc: DEBUG

// =========================================

src/main/resources/config/tree-config.yml

# config/tree-config.yml
# PostgreSQL 树结构配置（当前仅针对 PostgreSQL，后续扩展其他 dbType）
treeConfigs:
  POSTGRESQL:
    # 连接级别图标
    icon: "pgsql_icon.svg"
    # 基础层级定义（从 connection 开始，逐层展开）
    levels:
      # 第一层：Databases
      - type: "database"
        label: "数据库"
        icon: "db_icon.svg"
        # SQL 查询模板：占位符如 {connId} 将由后端替换为实际连接参数
        sqlQuery: |
          SELECT datname AS name, datname AS id
          FROM pg_database
          WHERE datistemplate = false AND datallowconn = true
          ORDER BY datname;
        # 动作配置（primary 为默认主动作，menu 为右键菜单项）
        actions:
          primary:
            label: "刷新"
            icon: "🔄"
            handler: "refreshDatabase"  # 前端函数名或后端端点
          menu:
            - label: "新建 Schema"
              icon: "📁"
              handler: "createNewSchema"
            - label: "导出结构"
              icon: "📤"
              handler: "exportDatabase"
            - type: "separator"
            - label: "删除数据库"
              icon: "🗑️"
              handler: "deleteDatabase"
              variant: "danger"
            - label: "属性"
              icon: "ℹ️"
              handler: "showProperties"
        # 下一层引用
        nextLevel: "schema"
      # 第二层：Schemas
      - type: "schema"
        label: "Schema"
        icon: "schema_icon.svg"
        sqlQuery: |
          SELECT schema_name AS name, schema_name AS id
          FROM information_schema.schemata
          WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast', 'pg_temp_1')
          AND schema_name = ANY (SELECT nspname FROM pg_namespace WHERE nspacl IS NOT NULL)
          ORDER BY schema_name;
        actions:
          primary:
            label: "刷新"
            icon: "🔄"
            handler: "refreshSchema"
          menu:
            - label: "新建表"
              icon: "📊"
              handler: "createNewTable"
            - label: "新建视图"
              icon: "👁️"
              handler: "createNewView"
            - label: "新建函数"
              icon: "⚙️"
              handler: "createNewFunction"
            - type: "separator"
            - label: "导出结构"
              icon: "📤"
              handler: "exportSchema"
            - label: "删除 Schema"
              icon: "🗑️"
              handler: "deleteSchema"
              variant: "danger"
            - label: "属性"
              icon: "ℹ️"
              handler: "showProperties"
        nextLevel: "objects"  # 指向聚合层
      # 第三层：Objects（聚合层：支持多种子类型，自动创建虚拟聚合节点）
      - type: "objects"
        label: "对象"
        icon: "objects_icon.svg"  # 默认聚合图标
        # 无直接 SQL，此层为虚拟聚合，根据 groupBy 执行子查询
        groupBy:  # 定义子类型分组，每个分组为一个虚拟节点
          # Tables 分组
          tables:
            type: "table_group"  # 虚拟聚合节点类型
            label: "Tables"  # 聚合节点显示标签
            icon: "tables_group.svg"
            sqlQuery: |
              SELECT table_name AS name, table_name AS id, 'table' AS subType
              FROM information_schema.tables
              WHERE table_schema = '{schemaName}'  # 占位符：当前 schema
              AND table_type = 'BASE TABLE'
              ORDER BY table_name;
            actions:
              primary:
                label: "预览"
                icon: "📊"
                handler: "previewTable"
              menu: []  # 聚合节点无额外菜单，或继承子节点
            # 子节点配置（注入到每个 table 节点）
            childConfig:
              type: "table"
              icon: "table_icon.svg"
              actions:
                primary:
                  label: "预览数据"
                  icon: "📊"
                  handler: "previewTable"
                menu:
                  - label: "编辑结构"
                    icon: "✏️"
                    handler: "editTableStructure"
                  - label: "生成 SQL"
                    icon: "💾"
                    handler: "generateTableSQL"
                  - label: "导出数据"
                    icon: "📤"
                    handler: "exportTableData"
                  - type: "separator"
                  - label: "删除表"
                    icon: "🗑️"
                    handler: "deleteTable"
                    variant: "danger"
          # Views 分组
          views:
            type: "view_group"
            label: "Views"
            icon: "views_group.svg"
            sqlQuery: |
              SELECT table_name AS name, table_name AS id, 'view' AS subType
              FROM information_schema.views
              WHERE table_schema = '{schemaName}'
              ORDER BY table_name;
            actions:
              primary:
                label: "查看定义"
                icon: "👁️"
                handler: "viewDefinition"
              menu: []
            childConfig:
              type: "view"
              icon: "view_icon.svg"
              actions:
                primary:
                  label: "查看定义"
                  icon: "👁️"
                  handler: "viewDefinition"
                menu:
                  - label: "编辑视图"
                    icon: "✏️"
                    handler: "editView"
                  - label: "生成 SQL"
                    icon: "💾"
                    handler: "generateViewSQL"
                  - type: "separator"
                  - label: "删除视图"
                    icon: "🗑️"
                    handler: "deleteView"
                    variant: "danger"
          # Materialized Views 分组
          materialized_views:
            type: "mview_group"
            label: "Materialized Views"
            icon: "mviews_group.svg"
            sqlQuery: |
              SELECT matviewname AS name, matviewname AS id, 'materialized_view' AS subType
              FROM pg_matviews
              WHERE schemaname = '{schemaName}'
              ORDER BY matviewname;
            actions:
              primary:
                label: "预览"
                icon: "📊"
                handler: "previewTable"  # 复用 table 预览
              menu: []
            childConfig:
              type: "materialized_view"
              icon: "mview_icon.svg"
              actions:
                primary:
                  label: "预览数据"
                  icon: "📊"
                  handler: "previewTable"
                menu:
                  - label: "刷新物化视图"
                    icon: "🔄"
                    handler: "refreshMaterializedView"
                  - label: "编辑结构"
                    icon: "✏️"
                    handler: "editTableStructure"
                  - type: "separator"
                  - label: "删除物化视图"
                    icon: "🗑️"
                    handler: "deleteView"  # 复用 view 删除
                    variant: "danger"
          # Functions 分组
          functions:
            type: "function_group"
            label: "Functions"
            icon: "functions_group.svg"
            sqlQuery: |
              SELECT p.proname AS name,
                     p.proname || '(' || pg_get_function_arguments(p.oid) || ')' AS id,
                     'function' AS subType,
                     pg_get_function_arguments(p.oid) AS args
              FROM pg_proc p
              JOIN pg_namespace n ON p.pronamespace = n.oid
              WHERE n.nspname = '{schemaName}'
              AND p.prokind = 'f'  # 函数
              ORDER BY p.proname;
            actions:
              primary:
                label: "编辑"
                icon: "⚙️"
                handler: "editFunction"
              menu: []
            childConfig:
              type: "function"
              icon: "function_icon.svg"
              actions:
                primary:
                  label: "编辑函数"
                  icon: "✏️"
                  handler: "editFunction"
                menu:
                  - label: "查看源码"
                    icon: "👁️"
                    handler: "viewFunctionSource"
                  - label: "执行测试"
                    icon: "🔬"
                    handler: "testFunction"
                  - type: "separator"
                  - label: "删除函数"
                    icon: "🗑️"
                    handler: "deleteFunction"
                    variant: "danger"
        # 聚合层通用动作（继承到虚拟节点）
        actions:
          primary:
            label: "展开"
            icon: "▶"
            handler: "toggleExpand"
          menu:
            - label: "刷新"
              icon: "🔄"
              handler: "refreshObjects"
    # 额外可选层级（全局或特定位置插入，如在 databases 旁）
    extraLevels:
      # Publications（全局或在 connection 下一级）
      publications:
        type: "publications"
        label: "Publications"
        icon: "publications_icon.svg"
        sqlQuery: |
          SELECT pubname AS name, pubname AS id
          FROM pg_publication
          ORDER BY pubname;
        actions:
          primary:
            label: "查看"
            icon: "👁️"
            handler: "viewPublication"
          menu:
            - label: "新建 Publication"
              icon: "➕"
              handler: "createPublication"
            - type: "separator"
            - label: "删除"
              icon: "🗑️"
              handler: "deletePublication"
              variant: "danger"
        # 可作为 connection 的并行子层（非树状嵌套）
        position: "connection"  # 插入位置：connection, database 等
      # Roles/Users（全局）
      roles:
        type: "roles"
        label: "Roles/Users"
        icon: "roles_icon.svg"
        sqlQuery: |
          SELECT rolname AS name, rolname AS id
          FROM pg_roles
          WHERE rolcanlogin = true  # 可登录用户
          ORDER BY rolname;
        actions:
          primary:
            label: "属性"
            icon: "ℹ️"
            handler: "showRoleProperties"
          menu:
            - label: "新建角色"
              icon: "➕"
              handler: "createRole"
            - type: "separator"
            - label: "删除角色"
              icon: "🗑️"
              handler: "deleteRole"
              variant: "danger"
        position: "connection"  # 插入到 connection 下一级

// =========================================

